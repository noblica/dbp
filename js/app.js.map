{"version":3,"sources":["app/TestModule/test.module.js","app/app.js","app/core/core.module.js","app/core/pipeline/pipeline.module.js","app/TestModule/test.controller.js","app/app.controller.js","app/codeInput/ALU.service.js","app/codeInput/codeInput.controller.js","app/codeInput/codeInput.directive.js","app/core/common.service.js","app/core/jmpInstruction.service.js","app/core/label.service.js","app/core/pc.service.js","app/core/pipeline/EX.model.js","app/core/pipeline/EX.service.js","app/core/pipeline/ID.model.js","app/core/pipeline/ID.service.js","app/core/pipeline/IF.model.js","app/core/pipeline/IF.service.js","app/core/pipeline/WB.model.js","app/core/pipeline/WB.service.js","app/core/registers.service.js","app/corelationRegister/corelationRegister.controller.js","app/corelationRegister/corelationRegister.directive.js","app/corelationRegister/corelationRegister.service.js","app/localHistoryTable/localHistoryTable.controller.js","app/localHistoryTable/localHistoryTable.directive.js","app/localHistoryTable/localHistoryTable.service.js","app/predictionMachines/predictionMachines.controller.js","app/predictionMachines/predictionMachines.directive.js","app/predictionMachines/predictionMachines.service.js","node_modules/browser-sync-brunch/lib/vendor/browser-sync-injector.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrCA;AACA;AACA;AACA;AACA;AACA;ACLA;AACA;AACA;AACA;AACA;AACA;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CCrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChFA;AACA;AACA;AACA;AACA;AACA;AACA","file":"public/js/app.js","sourcesContent":["(function() {\n    'use strict';\n    \n    angular.module('test', []);\n})();","(function() {\n    'use strict';\n    \n    angular.module('app', ['ui.router',\n                            'ui.bootstrap',\n                            'ngAnimate',\n                            'core', \n                            'pipeline',\n                           'test'])\n        .config(routeConfiguration);\n    \n    routeConfiguration.$inject = ['$stateProvider', '$urlRouterProvider'];\n    function routeConfiguration($stateProvider, $urlRouterProvider) {\n        $stateProvider\n            .state('app', {\n                abstract: true,\n                controller: 'AppController',\n                controllerAs: 'app',\n                template: '<ui-view></ui-view>'\n            })\n            .state('app.home', {\n                url: '',\n                controller: 'TestController',\n                controllerAs: 'vm',\n                templateUrl: 'app/TestModule/test.html'\n            });\n        \n        $urlRouterProvider\n            .when('', goHome)\n            .when('/', goHome)\n            .otherwise('/error/404');\n        \n        goHome.$inject = ['$state'];\n        function goHome($state) {\n            $state.go('app.home');\n        }\n    }\n})();","(function() {\n    'use strict';\n\n    angular.module('core', []);\n    \n})();","(function() {\n    'use strict';\n\n    angular.module('pipeline', []);\n    \n})();","(function() {\n    'use strict';\n\n    angular.module('test')\n        .controller('TestController', TestController);\n\n    TestController.$inject = [];\n    function TestController() {\n        var vm = this;\n\n        vm.corelationRegisterCollapse = false;\n        vm.localHistoryCollapse = true;\n        vm.predictionMachinesCollapse = true;\n\n        vm.toggleLocalHistory = toggleLocalHistory;\n\n        activate();\n\n        function activate() {}\n\n        function toggleLocalHistory(historyHandler) {\n            vm.localHistoryCollapse = !vm.localHistoryCollapse;\n            console.log(vm.localHistoryCollapse);\n        }\n    }\n})();\n","(function() {\n    'use strict';\n    \n    angular.module('app')\n        .controller('AppController', AppController);\n    \n    AppController.$inject = [];\n    function AppController() {\n        var vm = this;\n        \n        activate();\n        \n        function activate() {\n            console.log('Layout controller loaded!');    \n        }\n    }\n})();","/**\n * A service that decodes the operation,\n * and actually executes it, and also sets the corresponding flags.\n */\n\n(function() {\n  'use strict';\n\n  /*jshint bitwise: false*/\n  /*jshint maxcomplexity: false*/\n  angular.module('app')\n    .factory('aluService', aluService);\n\n  aluService.$inject = ['registerService'];\n  function aluService(registerService) {\n    var service = {\n        flags: {\n            ZF: false,\n            CF: false,\n            OF: false,\n            SF: false\n        },\n        a: 0,\n        aRegName: '',\n        b: 0,\n        bRegName: '',\n        cmpResult: 0,\n        maxValue: Math.pow(2, 16) - 1,\n        maxValueSigned: Math.pow(2, 15) - 1,\n        bitSize: 15,\n\n        compareAndSetFlags: compareAndSetFlags\n\n        // cmpResult values:\n        // 0 - Previous comparison result is a = b\n        // <0 - Previous comparison is a < b\n        // >0 - Previous comparison is a > b\n    };\n\n    return service;\n\n    /**\n     * Helper function for setiting the maximum value allowed.\n     * The value should be set in bits.\n     */\n    function setMaxValue(newBitValue) {\n        service.maxValue = Math.pow(2, newBitValue) - 1;\n        service.maxValueSigned = Math.pow(2, newBitValue - 1) - 1;\n        return service.maxValue;\n    }\n    \n    function setRegNamesAndValues(value1, value2) {\n        \n        // service.a = registerService.getValueOfReg(value1) || service.a;\n        service.a = registerService.getValueOfReg(value1);\n        service.b = Number(value2) !== undefined ? \n                    Number(value2) :\n                    service.b;\n        \n        /**\n         * If the second operator is not a number,\n         * it can only be a name of a register.\n         * So we fetch the value from that register, and use it from here on out.\n         */\n        if (isNaN(value2)) {\n            service.bRegName = value2;\n            service.b = registerService.getValueOfReg(value2);\n        }\n    }\n    \n    /**\n     * Decodes the operation using switch-case,\n     * assigns the parsed values to the service,\n     * executes the operation, and sets the flags.\n     */\n    function compareAndSetFlags(newA, newB, operation) {\n        \n        /**\n         * Get the values.\n         * If they aren't being passed in, assign the previous values,\n         * to the temporary variables\n         */\n        setRegNamesAndValues(newA, newB);\n\n        var cmpResult = service.cmpResult;\n        var aSign = getSign(service.a);\n        var bSign = getSign(service.b);\n        var cmpSign = null;\n\n        switch (operation) {\n            case 'mov':\n                registerService.setValueOfReg(service.aRegName, service.b);\n                cmpResult = service.b;\n            break;\n\n            case 'add':\n                cmpResult = service.a + service.b;\n\n                setCF(false);\n                setOF(false);\n\n                if (Math.abs(cmpResult) > service.maxValue) {\n                    setCF(true);\n                    cmpResult = truncateResult(cmpResult);\n                }\n\n                cmpSign = getSign(cmpResult);\n                if (signChanged(aSign, bSign, cmpSign)) {\n                        setOF(true);\n                    }\n                    \n                registerService.setValueOfReg(service.aRegName, cmpResult);\n            break;\n\n            case 'sub':\n            case 'cmp':\n                setCF(false);\n                setOF(false);\n                setZF(false);\n                \n                cmpResult = truncateResult(service.a - service.b);\n                                \n                if (service.b > service.a) {\n                    setCF(true);\n                }\n\n                if (service.b === service.a) {\n                    setZF(true);\n                }\n\n                cmpSign = getSign(cmpResult);\n\n                if (signChanged(aSign, bSign, cmpSign)) {\n                    setOF(true);\n                }\n                \n                registerService.setValueOfReg(service.aRegName, cmpResult);\n            break;\n\n            case 'mul':\n                setCF(false);\n                setOF(false);\n                setZF(false);\n\n                cmpResult = service.a * service.b;\n\n                if (cmpResult === 0) {\n                    setZF(true);\n                }\n\n                if (Math.abs(cmpResult) > service.maxValue) {\n                    setCF(true);\n                    cmpResult = truncateResult(cmpResult);\n                }\n\n                cmpSign = getSign(cmpResult);\n                if (signChanged(aSign, bSign, cmpSign)) {\n                        setOF(true);\n                    }\n            break;\n\n            case 'div':\n                setOF(false);\n                \n                cmpResult = service.a / service.b;\n\n                if (cmpSign === Infinity) {\n                        setOF(true);\n                    }\n            break;\n\n            case 'and':                \n                cmpResult = service.a & service.b;\n                setSF(!!getSign(cmpResult));\n                registerService.setValueOfReg(service.aRegName, cmpResult);\n            break;\n\n            case 'or':\n                cmpResult = service.a | service.b;\n                setSF(!!getSign(cmpResult));\n                registerService.setValueOfReg(service.aRegName, cmpResult);\n            break;\n\n            case 'xor':\n                cmpResult = service.a ^ service.b;\n                setSF(!!getSign(cmpResult));\n                registerService.setValueOfReg(service.aRegName, cmpResult);\n            break;\n\n            case 'test':\n                setZF(false);\n                setSF(false);\n                \n                cmpResult = service.a & service.b;\n                \n                if (cmpResult === 0) {\n                    setZF(true);\n                }\n                \n                setSF(!!getSign(cmpResult));\n            break;\n\n            case 'not':\n                cmpResult = ~service.a;\n                registerService.setValueOfReg(service.aRegName, cmpResult);\n            break;\n        }\n\n        service.cmpResult = cmpResult;\n        return service.cmpResult;\n    }\n    \n    /**\n     * A helper funtion for checking if the sign has changed.\n     * Useful if called after the operation was executed.\n     * It needs both operator signs, and the result sign.\n     */\n    function signChanged(aSign, bSign, cmpSign) {\n        return ((aSign === bSign) &&\n                (cmpSign !== aSign));\n    }\n\n    /**\n     * A helper function for fetching the sign of a passed in number.\n     * The number is truncated (just in case),\n     * converted to it's binary form,\n     * split, so that each number is an element in an array,\n     * reversed (because fetching the [0] element of the array doesn't always represent it's sign),\n     * and it's last bit is fetched (which, when it's reversed, represents the number)\n     * \n     * The value will be 0 if the number is > 0, or 1 if the number is < 0.\n     */\n    function getSign(number) {\n        var bitSize = service.bitSize;\n        var truncatedValue = truncateResult(number);\n        var bitValue = truncatedValue.toString(2);\n        var sign = Number(bitValue.split('').reverse()[bitSize]);\n\n        return sign ? sign : 0;\n    }\n    \n    /**\n     * A function that returns truncated value of the number passed in.\n     */\n    function truncateResult(result) {\n        return Number(result) & service.maxValue;\n    }\n\n    // Function for setting the zero flag\n    function setZF(newZFValue) {\n        service.flags.ZF = newZFValue === undefined ?\n                        (service.cmpResult === 0) :\n                        newZFValue;\n        return service.flags;\n    }\n\n    // Function for setting the carry flag\n    function setCF(newCFValue) {\n        service.flags.CF = newCFValue === undefined ?\n                        service.flags.CF :\n                        newCFValue;\n        return service.flags;\n    }\n\n    // Function for setting the overflow flag\n    function setOF(newOFValue) {\n        service.flags.OF = newOFValue;\n\n        if (newOFValue === undefined) {\n            service.flags.OF = newOFValue === undefined ? \n                                service.flags.OF :\n                                newOFValue;\n        }\n        return service.flags;\n    }\n\n    // Sign/Negative flag\n    function setSF(newSFValue) {\n        service.flags.SF = newSFValue ||\n                        (service.cmpResult < 0) ||\n                        (service.cmpResult > service.maxValue);\n        return service.flags;\n    }\n  }\n})();\n","(function() {\n  'use strict';\n\n  angular.module('app')\n    .controller('CodeInputController', CodeInputController);\n\n    // jshint maxparams:13\n\n  CodeInputController.$inject = ['IFService',\n                                  'IFModel',\n                                'IDService',\n                                'IDModel',\n                                'EXService',\n                                'EXModel',\n                                'WBService',\n                                'WBModel',\n                                'labelService',\n                                'pcService',\n                                'common',\n                                '$interval'];\n\n  function CodeInputController(IFService,\n                              IFModel,\n                              IDService,\n                              IDModel,\n                              EXService,\n                              EXModel,\n                              WBService,\n                              WBModel,\n                              labelService,\n                              pcService,\n                              common,\n                              $interval) {\n    var vm = this;\n                            \n    vm.codeInput = 'mov ax, 0\\nmov bx, 2\\nl1:\\nadd ax, 1\\ncmp ax, bx\\njl l1\\nend';\n    vm.stepByStep = false;\n    vm.codeArray = [];\n    vm.pipelineStarted = false;\n\n    vm.IFModel = IFModel;\n    vm.IDModel = IDModel;\n    vm.EXModel = EXModel;\n    vm.WBModel = WBModel;\n    vm.common = common;\n\n    vm.doPrediction = doPrediction;\n    vm.goToNextBranchInstruction = goToNextBranchInstruction;\n\n    function doPrediction(codeInput) {\n      var codeSplitByLine = codeInput.split('\\n');\n      var codeArray = removeJustNewlines(codeSplitByLine);\n      vm.codeArray = labelService.setAndRemoveLabelsFromCodeArray(codeArray);\n\n      vm.pipelineStarted = true;\n      \n      // Initial PC value (not yet started)\n      pcService.pc = -1;\n\n      if (vm.stepByStep){\n        pcService.setNewPc();\n        parseAll(pcService.pc, vm.codeArray);\n      } else {\n        setIterationInterval(vm.codeArray);\n      }\n    }\n\n    function goToNextBranchInstruction(codeArray) {\n\n      if (isLastInstructionInWb(codeArray)) {\n          common.flushPipeline();\n          common.flushPipeline(false, false, false, true);\n          vm.pipelineStarted = false;\n        } else {\n          iterateThePipeline(pcService.pc, codeArray);\n        }\n    }\n\n    function setIterationInterval(codeArray) {\n      var pipelineInterval = $interval(function() {\n        \n        if (isLastInstructionInWb(codeArray)) {\n          $interval.cancel(pipelineInterval);\n          common.flushPipeline();\n          common.flushPipeline(false, false, false, true);\n          vm.pipelineStarted = false;\n        } else {\n          iterateThePipeline(pcService.pc, codeArray);\n        }\n      }, 10);\n    }\n    \n    function isLastInstructionInWb(codeArray) {\n      // return (pcService.pc > WBModel.currentPc) && \n      //         (WBModel.currentPc >= codeArray.length);\n      return WBModel.instructionsInWB.some(function(instructionObj) {\n          return instructionObj.operation === 'end';\n      });\n    }\n      \n    function removeJustNewlines(arrayWithNewlines) {\n      var arrayWithoutNewlines = arrayWithNewlines.filter(function(value) {\n        return value !== '';\n      });\n      \n      return arrayWithoutNewlines; \n    }\n    \n    function iterateThePipeline(pc, codeArray, howMany) {\n\n      pipeThroughAll()\n        .then(function() {\n          pcService.setNewPc();\n          var parsePromise = parseAll(pcService.pc, codeArray, howMany);\n          return parsePromise;\n      });\n    }\n\n    function parseAll(pc, codeArray, howMany) {\n      return IFService.parse(pc, codeArray, 1)\n          .then(IDService.parse)\n          .then(EXService.parse)\n          .then(WBService.parse)\n          .then(function(response) {\n            console.log(response);\n          });\n    }\n\n    function pipeThroughAll() {\n      return WBService.pipeThrough()\n          .then(EXService.pipeThrough)\n          .then(IDService.pipeThrough)\n          .then(IFService.pipeThrough);\n    }\n\n  }\n})();\n\n\n// Following are the conditional jump instructions used on signed data used for arithmetic operations −\n//\n// Instruction\tDescription\tFlags tested\n// JE/JZ\tJump Equal or Jump Zero\tZF\n// JNE/JNZ\tJump not Equal or Jump Not Zero\tZF\n// JG/JNLE\tJump Greater or Jump Not Less/Equal\tOF, SF, ZF\n// JGE/JNL\tJump Greater/Equal or Jump Not Less\tOF, SF\n// JL/JNGE\tJump Less or Jump Not Greater/Equal\tOF, SF\n// JLE/JNG\tJump Less/Equal or Jump Not Greater\tOF, SF, ZF\n// Following are the conditional jump instructions used on unsigned data used for logical operations −\n//\n// Instruction\tDescription\tFlags tested\n// JE/JZ\tJump Equal or Jump Zero\tZF\n// JNE/JNZ\tJump not Equal or Jump Not Zero\tZF\n// JA/JNBE\tJump Above or Jump Not Below/Equal\tCF, ZF\n// JAE/JNB\tJump Above/Equal or Jump Not Below\tCF\n// JB/JNAE\tJump Below or Jump Not Above/Equal\tCF\n// JBE/JNA\tJump Below/Equal or Jump Not Above\tAF, CF\n// The following conditional jump instructions have special uses and check the value of flags −\n//\n// Instruction\tDescription\tFlags tested\n// JXCZ\tJump if CX is Zero\tnone\n// JC\tJump If Carry\tCF\n// JNC\tJump If No Carry\tCF\n// JO\tJump If Overflow\tOF\n// JNO\tJump If No Overflow\tOF\n// JP/JPE\tJump Parity or Jump Parity Even\tPF\n// JNP/JPO\tJump No Parity or Jump Parity Odd\tPF\n// JS\tJump Sign (negative value)\tSF\n// JNS\tJump No Sign (positive value)\tSF\n// The syntax for the J<condition> set of instructions −\n//\n// Example,\n//\n// CMP\tAL, BL\n// JE\tEQUAL\n// CMP\tAL, BH\n// JE\tEQUAL\n// CMP\tAL, CL\n// JE\tEQUAL\n// NON_EQUAL: ...\n// EQUAL: ...\n","(function() {\n  'use strict';\n\n  angular.module('app')\n    .directive('codeInput', codeInput);\n\n  codeInput.$inject = [];\n  function codeInput() {\n    var directive = {\n      restrict: 'E',\n      controller: 'CodeInputController',\n      controllerAs: 'ci',\n      templateUrl: 'app/codeInput/code-input.html'\n    };\n\n    return directive;\n  }\n})();\n","(function() {\n    'use strict';\n\n    angular.module('core')\n        .factory('common', common);\n\n    common.$inject = ['IFModel', \n                      'IDModel',\n                      'EXModel',\n                      'WBModel'];\n                      \n    function common(IFModel, \n                       IDModel,\n                       EXModel,\n                       WBModel) {\n                           \n        var service = {\n            flushPipeline: flushPipeline,\n            instructionToText: instructionToText\n        };\n\n        return service;\n        \n        function flushPipeline(flushIf, flushId, flushEx, flushWb) {\n      \n            if (flushIf === undefined) {\n                IFModel.flush();\n                IDModel.flush();\n                EXModel.flush();\n            } else {\n            \n                if (flushIf) {\n                    IFModel.flush();\n                }\n                \n                if (flushId) {\n                    IDModel.flush();\n                }\n                \n                if (flushEx) {\n                    EXModel.flush();\n                }\n                \n                if (flushWb) {\n                    WBModel.flush();\n                }\n            }\n        }\n\n        function instructionToText(instructionObject) {\n            var firstOperatorExists = instructionObject.firstOperator !== (undefined || null);\n            var secondOperatorExists = instructionObject.secondOperator !== (undefined || null); \n\n            return instructionObject.operation + ' ' +\n            (firstOperatorExists ?\n             instructionObject.firstOperator :\n             '') +\n             (secondOperatorExists ? \n             (', ' + instructionObject.secondOperator) :\n             (''));\n        }\n    }\n})();","(function() {\n    'use strict';\n    \n  /*jshint maxcomplexity: false*/\n    angular.module('core')\n        .factory('jmpInstructionService', jmpInstructionService);\n\n    jmpInstructionService  .$inject = ['aluService'];\n    function jmpInstructionService (aluService) {\n        var service = {\n            jmpInstructions: [],\n            isJmpInstruction: isJmpInstruction,\n            checkBranchCondition: checkBranchCondition\n        };\n        \n        activate();\n\n        return service;\n        \n        function activate() {\n            service.jmpInstructions = ['jmp', 'je', 'jz', 'jne',\n                                        'jnz', 'jg', 'jnle', 'jge',\n                                        'jnl', 'jl', 'jnge', 'jle',\n                                        'jng'];\n        }\n        \n        function isJmpInstruction(operation) {\n            return service.jmpInstructions.indexOf(operation) !== -1;\n        }\n        \n        function checkBranchCondition(operation) {\n            var aluFlags = aluService.flags;\n            \n            switch(operation) {\n                case 'jmp': \n                return true;\n                \n                case 'je':\n                case 'jz':\n                return aluFlags.ZF;\n                \n                case 'jne':\n                case 'jnz':\n                return !aluFlags.ZF;\n                \n                case 'jg':\n                case 'jnle':\n                return (!aluFlags.ZF && (aluFlags.SF === aluFlags.OF));\n                \n                case 'jge':\n                case 'jnl':\n                return aluFlags.SF === aluFlags.OF;\n                \n                case 'jl':\n                case 'jnge':\n                return (aluFlags.SF !== aluFlags.OF);\n                \n                case 'jle':\n                case 'jng':\n                return (aluFlags.ZF) || (aluFlags.SF !== aluFlags.OF);\n            }\n        }\n    }\n})();\n","(function() {\n    'use strict';\n\n    angular.module('core')\n        .factory('labelService', labelService);\n\n    labelService.$inject = [];\n    function labelService() {\n        var service = {\n            labelArray: [],\n            \n            getAddress: getAddress,\n            setLabelAddress: setLabelAddress,\n            setAndRemoveLabelsFromCodeArray: setAndRemoveLabelsFromCodeArray\n        };\n\n        return service;\n        \n        function setLabelAddress(label, address) {\n            var objectToPush = {};\n            objectToPush[label.toLowerCase()] = address;\n            service.labelArray.push(objectToPush);\n        }\n        \n        function getAddress(label) {\n            var labelObjectToReturn = null;\n                        \n            service.labelArray.some(function(labelObject) {\n                if (labelObject[label] !== undefined) {\n                    labelObjectToReturn = labelObject;\n                    return true;\n                }\n            });\n            \n            return labelObjectToReturn[label];\n        }\n        \n        function setAndRemoveLabelsFromCodeArray(codeArray) {\n            var codeArrayToReturn = codeArray;\n            var index = 0;\n            \n            while (index < codeArray.length){\n                var codeString = codeArray[index];\n                \n                if (codeString.indexOf(':') !== -1) {\n                    var label = codeString.slice(0, codeString.indexOf(':'));\n                    \n                    codeArrayToReturn.splice(index, 1);\n                    setLabelAddress(label, index);\n                }\n                else {\n                    index++;\n                }\n            }            \n            return codeArrayToReturn;\n        }\n    }\n})();","(function() {\n    'use strict';\n\n    angular.module('core')\n        .factory('pcService', pcService);\n\n    pcService.$inject = [];\n    function pcService() {\n        var service = {\n            pc: -1,\n            branchesPredictedTaken: [],\n            overridePc: null,\n\n            setNewPc: setNewPc\n        };\n\n        return service;\n\n        function setNewPc() {\n\n            service.pc += 1;\n            if (service.overridePc !== null) {\n                service.pc = service.overridePc;\n                service.overridePc = null;\n            }\n        }\n    }\n})();\n","(function() {\n    'use strict';\n\n    angular.module('core')\n        .factory('EXModel', EXModel);\n\n    EXModel.$inject = [];\n    function EXModel() {\n        var service = {\n            currentPc: null,\n            returnPromise: null,\n            nextPredictionFalse: false,\n            instructionsInEX: [],\n            writeBackResults: [],\n\n            flush: flush\n        };\n\n        return service;\n\n        function flush() {\n            service.currentPc = 0;\n            service.instructionsInEX = [];\n            service.writeBackResults = [];\n            var objectToResolve = {\n                currentPc: service.currentPc,\n                instructionSet: service.instructionsInEX,\n                writeBackResults: service.writeBackResults\n            };\n\n            // Resolving, so that the pipeline doesn't stall,\n            // even though we're flushing.\n            service.returnPromise.resolve(objectToResolve);\n        }\n    }\n})();\n","(function() {\n    'use strict';\n\n    angular.module('core')\n        .factory('EXService', EXService);\n\n    EXService.$inject = ['$q', \n                         'aluService',\n                         'jmpInstructionService',\n                         'labelService',\n                         'pcService',\n                         'EXModel',\n                         'common',\n                         'predictionMachinesService'];\n    function EXService($q, \n                       aluService,\n                       jmpInstructionService,\n                       labelService,\n                       pcService,\n                       EXModel,\n                       common,\n                       predictionMachinesService) {\n        var service = {\n            parse: parse,\n            pipeThrough: pipeThrough,\n            parseJumpInstruction: parseJumpInstruction\n        };\n\n        return service;\n        \n        function parse(objectFromId) {\n            EXModel.currentPc = objectFromId.currentPc;\n            EXModel.instructionsInEX = objectFromId.instructionSet;\n            EXModel.writeBackResults = [];\n            \n            decodeInstructions(EXModel.instructionsInEX);\n            EXModel.returnPromise = $q.defer();\n            \n            return EXModel.returnPromise.promise;\n        }\n        \n        function parseJumpInstruction(instruction, index) {\n            var branchTaken = jmpInstructionService.checkBranchCondition(instruction.operation);\n            var labelAddress = labelService.getAddress(instruction.firstOperator);\n            var currentOperationPc = EXModel.currentPc + index;\n            var branchPredictedIndex = pcService.branchesPredictedTaken.indexOf(currentOperationPc);\n\n            if (EXModel.nextPredictionFalse) {\n                branchTaken = !branchTaken;\n            }\n\n            // If branch should be taken, and it was predicted not taken \n            if (branchTaken &&\n                branchPredictedIndex === -1) {\n                // Flush instructions in IF and ID\n                common.flushPipeline(true, true);\n\n                // Set new PC\n                // pcService.pc = labelAddress;\n                pcService.overridePc = labelAddress;\n                \n                // Update predictions\n                predictionMachinesService.updatePredictions(1);\n\n                // The execution loop needs to be broken \n                return true;\n            }\n            \n            // If branch should be taken, and it was predicted taken \n            else if (branchTaken &&\n                        branchPredictedIndex !== -1) {\n\n                // Remove the prediction from the list of predicted taken\n                pcService.branchesPredictedTaken.splice(branchPredictedIndex, 1);\n\n                // Update predictions\n                predictionMachinesService.updatePredictions(1);\n            } \n\n            // If branch should not be taken, and it was predicted not taken \n            else if (!branchTaken &&\n                        branchPredictedIndex === -1) {\n\n                // Update predictions\n                predictionMachinesService.updatePredictions(0);\n            } \n\n            // If branch should not be taken, and it was predicted taken \n            else if (!branchTaken && \n                        branchPredictedIndex !== -1) {\n\n                // Flush instructions in IF and ID\n                common.flushPipeline(true, true);\n\n                // Set new PC\n                // pcService.pc = currentOperationPc + 1;\n                pcService.overridePc = currentOperationPc + 1;\n                \n                // Remove the prediction from the list of predicted taken\n                pcService.branchesPredictedTaken.splice(branchPredictedIndex, 1);\n\n                // Update predictions\n                predictionMachinesService.updatePredictions(0);\n\n                // The execution loop needs to be broken \n                return true;\n            }\n\n            // The execution loop should not be broken\n            return false;\n        }\n        \n        function parseALUInstruction(instruction) {\n            EXModel.writeBackResults = executeInstructions(instruction);\n        }\n        \n        function decodeInstructions(instructionsToDecode) {\n            \n            instructionsToDecode.some(function(operationObject, index) {\n                var operationFromId = operationObject.operation;\n                var isJmpInstruction = jmpInstructionService.isJmpInstruction(operationFromId);\n                \n                if (isJmpInstruction) {\n                    var jmpTaken = parseJumpInstruction(operationObject, index);\n                    return jmpTaken;\n                } else {\n                    parseALUInstruction(operationObject);\n                }\n            });\n            return EXModel.instructionsInEX;\n        }\n        \n        function pipeThrough() {\n            if (EXModel.returnPromise) {\n                var objectToPipe = {\n                    currentPc: EXModel.currentPc,\n                    instructionSet: EXModel.instructionsInEX,\n                    writeBackResults: EXModel.writeBackResults\n                };\n                \n                EXModel.returnPromise.resolve(objectToPipe);\n                return EXModel.returnPromise.promise;\n            }\n            \n            return $q.resolve();\n        }\n        \n        function executeInstructions(instruction) {\n            var firstOperator = instruction.firstOperator;\n            var secondOperator = instruction.secondOperator;\n            var operation = instruction.operation;\n            \n            var result = aluService.compareAndSetFlags(firstOperator, secondOperator, operation); \n            var writeBackObject = {\n                currentPc: EXModel.currentPc,\n                register: instruction.firstOperator,\n                result: result,\n                operation: operation\n            };\n            EXModel.writeBackResults.push(writeBackObject);\n\n            return EXModel.writeBackResults;\n        }\n    }\n})();","(function() {\n    'use strict';\n\n    angular.module('core')\n        .factory('IDModel', IDModel);\n\n    IDModel.$inject = [];\n    function IDModel() {\n        var service = {\n            currentPc: null,\n            returnPromise: null,\n            instructionsInID: [],\n            flush: flush\n        };\n\n        return service;\n\n        function flush() {\n            service.currentPc = 0;\n            service.instructionsInID = [];\n            var objectToResolve = {\n                currentPc: service.currentPc,\n                instructionSet: service.instructionsInID\n            };\n\n            // Resolving, so that the pipeline doesn't stall,\n            // even though we're flushing.\n            service.returnPromise.resolve(objectToResolve);\n        }\n    }\n})();\n","(function() {\n    'use strict';\n\n    angular.module('core')\n        .factory('IDService', IDService);\n\n    IDService.$inject = ['$q', 'IDModel'];\n    function IDService($q, IDModel) {\n        var service = {\n            parse: parse,\n            pipeThrough: pipeThrough,\n            decodeSingleInstruction: decodeSingleInstruction\n        };\n\n        return service;\n        \n        function parse(objectFromIf) {\n            IDModel.currentPc = objectFromIf.currentPc;\n            IDModel.instructionsInID = decodeInstructions(objectFromIf.instructionSet);\n            IDModel.returnPromise = $q.defer();\n            \n            return IDModel.returnPromise.promise;\n        }\n        \n        function pipeThrough() {\n            if (IDModel.returnPromise) {\n            \n                var objectToPipe = {\n                    currentPc: IDModel.currentPc,\n                    instructionSet: IDModel.instructionsInID\n                };\n                \n                IDModel.returnPromise.resolve(objectToPipe);\n                return IDModel.returnPromise.promise;\n            }\n            \n            return $q.resolve();\n        }\n\n        function decodeSingleInstruction(line) {\n            var removedCommaFromline = line.replace(',', '');\n                var splitBySpace = removedCommaFromline.split(' ');\n                \n                var decodedInstruction = {\n                    operation: splitBySpace[0].toLowerCase(),\n                    firstOperator: splitBySpace[1] === undefined ? \n                                                        null : \n                                                        splitBySpace[1].toLowerCase(),\n                    secondOperator: splitBySpace[2] === undefined ? \n                                                        null : \n                                                        splitBySpace[2].toLowerCase() \n                };\n\n            return decodedInstruction;\n        }\n        \n        function decodeInstructions(instructionsToDecode) {\n            var decodedInstructions = [];\n            \n            instructionsToDecode.forEach(function(line) {                \n                var newInstruction = decodeSingleInstruction(line);\n                \n                decodedInstructions.push(newInstruction);\n            });\n            return decodedInstructions;\n        }\n    }\n})();\n","(function() {\n    'use strict';\n\n    angular.module('core')\n        .factory('IFModel', IFModel);\n\n    IFModel.$inject = [];\n    function IFModel() {\n        var service = {\n            currentPc: null,\n            returnPromise: null,\n            instructionsInIF: [],\n\n            flush: flush\n        };\n\n        return service;\n\n        function flush() {\n            service.currentPc = 0;\n            service.instructionsInIF = [];\n            var objectToResolve = {\n                currentPc: service.currentPc,\n                instructionSet: service.instructionsInIF  \n            };\n\n            // Resolving, so that the pipeline doesn't stall,\n            // even though we're flushing.\n            service.returnPromise.resolve(objectToResolve);\n        }\n    }\n})();\n","(function() {\n    'use strict';\n\n    angular.module('core')\n        .factory('IFService', IFService);\n\n    IFService.$inject = ['$q', \n                        'IFModel',\n                        'IDService',\n                        'jmpInstructionService',\n                        'labelService',\n                        'pcService',\n                        'predictionMachinesService'];\n    function IFService($q,\n                        IFModel,\n                        IDService,\n                        jmpInstructionService,\n                        labelService,\n                        pcService,\n                        predictionMachinesService) {\n        var service = {\n            currentPc: null,\n            returnPromise: null,\n            instructionsInIF: [],\n            codeArrayInput: [],\n\n            parse: parse,\n            pipeThrough: pipeThrough\n        };\n\n        return service;\n        \n        /**\n         * Parses the instruction array, gets the required number of instructions \n         * (if nothing is passed, then it is presumed that the number of instructions is 1)\n         * from the instruction array.\n         * \n         * Returns a promise, which will be resolved when 'pipeThrough' is called.\n         */\n        function parse(currentPc, instructionArray, howManyInstructionsToPipe) {\n            IFModel.currentPc = currentPc || 0;\n            howManyInstructionsToPipe = howManyInstructionsToPipe || 1;\n            IFModel.returnPromise = $q.defer();\n            var sliceFrom = IFModel.currentPc;\n            var sliceTo = IFModel.currentPc + howManyInstructionsToPipe;\n            service.codeArrayInput = angular.copy(instructionArray);\n\n            var slicedInstructions = instructionArray.slice(sliceFrom, sliceTo);\n\n            checkForBranchInstructions(slicedInstructions);\n            IFModel.instructionsInIF = slicedInstructions;\n            return IFModel.returnPromise.promise;\n        }\n\n        function checkForBranchInstructions(instructionArray) {\n            var i = 0;\n\n            while (i < instructionArray.length) {\n                var currentLine = instructionArray[i];\n                var decodedInstruction = IDService.decodeSingleInstruction(currentLine);\n                // var instructionPc = i + pcService.pc;\n                var instructionPc = i + IFModel.currentPc;\n\n                var isJmpInstruction = jmpInstructionService.isJmpInstruction(decodedInstruction.operation);\n\n                if (isJmpInstruction && \n                    predictionMachinesService.getCurrentPrediction()) {\n                    var numOfInstructions = instructionArray.length - i - 1;\n                    var predictedAddress = getPredictedAddress(decodedInstruction);\n                    if (numOfInstructions > 0) {\n                    \n                        // We need to replace the instructions that are after the jump instruction\n                        // with the instructions that are predicted.\n                        var predictedValues = getPredictedValues(predictedAddress, numOfInstructions);\n\n                        // Append new instructions, to the array of instructions,\n                        // that will be passed to IDService.\n                        instructionArray.splice(i, numOfInstructions);\n                        instructionArray.concat(predictedValues);\n                    }\n\n                    /** Adding the predicted instruction\n                     *  to the array of predicted instructions.\n                     *  It will be used later, when the instruction executes\n                     */\n                    pcService.branchesPredictedTaken.push(instructionPc);\n\n                    // Setting the next PC.\n                    // pcService.pc = predictedAddress + numOfInstructions;\n                    pcService.overridePc = predictedAddress + numOfInstructions;\n\n                }\n                i++;\n            }\n\n            return instructionArray;\n        }\n\n        function getPredictedValues(labelAddress, num) {\n            var sliceToAddress = labelAddress + num;\n            \n            return service.codeArrayInput.slice(labelAddress, sliceToAddress);        \n        }\n\n        function getPredictedAddress(instructionObj) {\n            var label = instructionObj.firstOperator;\n            return labelService.getAddress(label);\n        }\n        \n        /**\n         * Resolves the promise with the required number of instructions\n         */        \n        function pipeThrough() {\n            if (IFModel.returnPromise) {\n                var objectToPipe = {\n                    currentPc: IFModel.currentPc,\n                    instructionSet: IFModel.instructionsInIF  \n                };\n                IFModel.returnPromise.resolve(objectToPipe);\n                return IFModel.returnPromise.promise;\n            }\n            return $q.resolve();\n        }\n    }\n})();\n","(function() {\n    'use strict';\n\n    angular.module('core')\n        .factory('WBModel', WBModel);\n\n    WBModel.$inject = [];\n    function WBModel() {\n        var service = {\n            currentPc: null,\n            returnPromise: null,\n            instructionsInWB: [],\n            writeBackResults: [],\n\n            flush: flush\n        };\n\n        return service;\n        \n        function flush() {\n            service.currentPc = 0;\n            service.instructionsInWB = [];\n            service.writeBackResults = [];\n            service.returnPromise.resolve();            \n        }\n    }\n})();\n","(function() {\n    'use strict';\n\n    angular.module('core')\n        .factory('WBService', WBService);\n\n    WBService.$inject = ['registerService', '$q', 'WBModel'];\n    function WBService(registerService, $q, WBModel) {\n        var dontWriteBack = ['cmp'];\n\n        var service = {\n            parse: parse,\n            pipeThrough: pipeThrough\n        };\n\n        return service;\n       \n       function parse(objectFromEx) {\n           WBModel.currentPc = objectFromEx.currentPc;\n           WBModel.instructionsInWB = objectFromEx.instructionSet;\n           WBModel.writeBackResults = objectFromEx.writeBackResults;\n           writeBack(objectFromEx.writeBackResults);\n           WBModel.returnPromise = $q.defer();\n           \n           return WBModel.returnPromise.promise;\n       }\n       \n        function writeBack(writeBackSet) {\n            writeBackSet.forEach(function(writeBackObject) {\n                var dst = writeBackObject.register;\n                var value = writeBackObject.result;\n                var op = writeBackObject.operation;\n                \n                if (shouldWriteBack(op)) {\n                    registerService.setValueOfReg(dst, value);\n                }\n            });\n        }\n\n        function shouldWriteBack(operation){\n            \n            /** If the operation is not in the dontWriteBack array\n             *  we shouldn't preform a WB operation on the first operator.\n             */\n            return dontWriteBack.indexOf(operation) === -1;\n        }\n        \n        function pipeThrough() {\n           if (WBModel.returnPromise) { \n                WBModel.returnPromise.resolve(WBModel.writeBackResults);\n                return WBModel.returnPromise.promise;\n            }\n            \n            return $q.resolve();\n        }\n    }\n})();","(function () {\n    'use strict';\n\n    angular.module('core')\n        .factory('registerService', registerService);\n\n    registerService.$inject = [];\n    function registerService() {\n        var service = {\n            coreRegisters: {\n                ax: 0,\n                bx: 0,\n                cx: 0,\n                dx: 0,\n                sp: 0,\n                bp: 0,\n                si: 0,\n                di: 0   \n            },\n            otherRegisters: {},\n            \n            getValueOfReg: getValueOfReg,\n            setValueOfReg: setValueOfReg\n        };\n\n        return service;\n\n        function getValueOfReg(regName) {\n            var regValue = 0;\n\n            if (service.coreRegisters[regName] !== undefined) {\n                regValue = service.coreRegisters[regName];\n\n            } else if (service.otherRegisters[regName] !== undefined) {\n                regValue = service.otherRegisters[regName];\n            } else {\n                service.otherRegisters[regName] = 0;\n            }\n\n            return regValue;\n        }\n\n        function setValueOfReg(regName, regValue) {\n\n            if (service.coreRegisters[regName] !== undefined) {\n                service.coreRegisters[regName] = regValue;\n            } else {\n                service.otherRegisters[regName] = regValue;\n            }\n            \n            return regName;\n        }\n    }\n})();","(function() {\n\t'use strict';\n\n\tangular.module('app')\n\t\t\t.controller('CorelationRegisterController', CorelationRegisterController);\n\n\tCorelationRegisterController.$inject = ['corelationRegisterService',\n\t'localHistoryTableService',\n\t'predictionMachinesService'];\n\tfunction CorelationRegisterController(corelationRegisterService,\n\t\tlocalHistoryTableService,\n\t\tpredictionMachinesService) {\n\n\t\tvar vm = this;\n\n\t\tvm.corelationRegister = corelationRegisterService;\n\t\tvm.locationHistoryTable = localHistoryTableService;\n\t\tvm.predictionMachines = predictionMachinesService;\n\n\t\tvm.updateValues = updateValues;\n\n\t\tactivate();\n\n\t\tfunction activate() {\n\t\t\t// vm.corelationRegister.setMaxNumberOfBits(service.size);\n\t\t\tvm.corelationRegister.initializeCR();\n\t\t}\n\n\t\tfunction updateValues() {\n\t\t\tvm.corelationRegister.setMaxNumberOfBits(vm.corelationRegister.size);\n\t\t\tvm.locationHistoryTable.initializeLHT();\n\t\t\tvm.predictionMachines.setMachineSize();\n\t\t}\n\t}\n})();\n","(function() {\n\t'use strict';\n\n\tangular.module('app')\n\t\t\t.directive('corelationRegister', corelationRegister);\n\n\tcorelationRegister.$inject = [];\n\tfunction corelationRegister() {\n\t\tvar directive = {\n\t\t\trestrict: 'E',\n\t\t\tcontroller: 'CorelationRegisterController',\n\t\t\tcontrollerAs: 'corReg',\n\t\t\ttemplateUrl: 'app/corelationRegister/corelation-register.html'\n\t\t};\n\n\t\treturn directive;\n\t}\n})();\n","\n(function() {\n\t'use strict';\n\n\tangular.module('app')\n\t\t.factory('corelationRegisterService', corelationRegisterService);\n\n  \tcorelationRegisterService.$inject = [];\n  \tfunction corelationRegisterService() {\n    \tvar service = {\n    \t\tvalue: [],\n\t\t\tsize: 3,\n\n    \t\tsetMaxNumberOfBits: setMaxNumberOfBits,\n    \t\tshiftWithValue: shiftWithValue,\n\t\t\tgetRegisterValue: getRegisterValue,\n\t\t\tinitializeCR: initializeCR\n    \t};\n\n    \treturn service;\n\n\t\tfunction initializeCR(newCRSize) {\n\t\t\tvar sizeOfCR = newCRSize || service.size;\n\n\t\t\tsetMaxNumberOfBits(sizeOfCR);\n\t\t}\n\n    \tfunction setMaxNumberOfBits(numberOfBits) {\n\t\t\tservice.value = [];\n\n            for (var i = 0; i < numberOfBits; i++) {\n                service.value[i] = 0;\n            }\n    \t}\n\n        function shiftWithValue(newValue) {\n            service.value.shift();\n            service.value.push(newValue);\n        }\n\n\t\tfunction getRegisterValue() {\n\t\t\tvar stringBinaryNumber = service.value.join('');\n\t\t\treturn parseInt(stringBinaryNumber, 2);\n\t\t}\n  \t}\n})();\n","(function() {\n  angular.module('app')\n    .controller('localHistoryTableController', localHistoryTableController);\n\n  localHistoryTableController.$inject = ['localHistoryTableService',\n                                        'predictionMachinesService'];\n  function localHistoryTableController(localHistoryTableService,\n                                        predictionMachinesService) {\n    var vm = this;\n\n    vm.localHistoryTable = localHistoryTableService;\n    vm.predictionMachines = predictionMachinesService;\n    vm.updateValues = updateValues;\n\n    activate();\n\n    function activate() {\n        vm.localHistoryTable.initializeLHT();\n    }\n\n    function updateValues() {\n        vm.localHistoryTable.initializeLHT();\n        vm.predictionMachines.setMachineSize();\n    }\n  }\n})();\n","(function() {\n\t'use strict';\n\n\tangular.module('app')\n\t\t\t.directive('localHistoryTable', localHistoryTable);\n\n\tlocalHistoryTable.$inject = [];\n\tfunction localHistoryTable() {\n\t\tvar directive = {\n\t\t\trestrict: 'E',\n\t\t\tcontroller: 'localHistoryTableController',\n\t\t\tcontrollerAs: 'lht',\n\t\t\ttemplateUrl: 'app/localHistoryTable/local-history-table.html'\n\t\t};\n\n\t\treturn directive;\n\t}\n})();\n","(function() {\n\t'use strict';\n\n\tangular.module('app')\n\t.factory('localHistoryTableService', localHistoryTableService);\n\n\tlocalHistoryTableService.$inject = ['corelationRegisterService'];\n  \tfunction localHistoryTableService(corelationRegisterService) {\n    \tvar service = {\n    \t\tvalue: [],\n\t\t\tsize: 3,\n\n    \t\tsetMaxNumberOfBits: setMaxNumberOfBits,\n    \t\tshiftWithValue: shiftWithValue,\n\t\t\tgetLocalHistoryValue: getLocalHistoryValue,\n\t\t\tinitializeLHT: initializeLHT\n    \t};\n\n\t\tactivate();\n\n    \treturn service;\n\n\t\tfunction activate() {}\n\n\t\tfunction initializeLHT(sizeOfRegister) {\n\t\t\tvar initialSize = sizeOfRegister || service.size;\n\t\t\tservice.value = [];\n\n\t\t\tsetMaxNumberOfBits(initialSize);\n\t\t}\n\n\t\tfunction setMaxNumberOfRegisters(numberOfLHTRegisters) {\n\t\t\tvar i = 0;\n\n\t\t\twhile (i < numberOfLHTRegisters) {\n\t\t\t\tservice.value[i++] = [];\n\t\t\t}\n\t\t}\n\n    \tfunction setMaxNumberOfBits(numberOfBits) {\n\t\t\tvar numOfRegisters = Math.pow(2, corelationRegisterService.size);\n\n\t\t\tsetMaxNumberOfRegisters(numOfRegisters);\n\n    \t\tservice.value = service.value.map(function(value) {\n    \t\t\tfor (var i = 0; i < numberOfBits; i++) {\n    \t\t\t\tvalue[i] = 0;\n    \t\t\t}\n    \t\t\treturn value;\n    \t\t});\n    \t}\n\n        function shiftWithValue(index, newValue) {\n            service.value[index].shift();\n            service.value[index].push(newValue);\n        }\n\n\t\tfunction getLocalHistoryValue(index) {\n\t\t\tvar lhStringValue = service.value[index].join('');\n\t\t\tvar lhValue = parseInt(lhStringValue, 2);\n\t\t\treturn lhValue;\n\t\t}\n  \t}\n})();\n","(function() {\n    'use strict';\n\n  angular.module('app')\n    .controller('PredictionMachinesController', PredictionMachinesController);\n\n  PredictionMachinesController.$inject = ['predictionMachinesService',\n                                        'corelationRegisterService',\n                                        'localHistoryTableService'];\n  function PredictionMachinesController(predictionMachinesService,\n                                        corelationRegisterService,\n                                        localHistoryTableService) {\n    var vm = this;\n\n    vm.numberOfMachines = predictionMachinesService.numOfMachines;\n    vm.predictionMachines = predictionMachinesService;\n\n    activate();\n\n    function activate() {\n        vm.predictionMachines.setMachineSize();\n    }\n  }\n})();\n","(function() {\n  angular.module('app')\n    .directive('predictionMachines', predictionMachines);\n\n  predictionMachines.$inject = [];\n  function predictionMachines() {\n    var directive = {\n      restrict : 'E',\n      controller: 'PredictionMachinesController',\n      controllerAs: 'pm',\n      templateUrl: 'app/predictionMachines/prediction-machines.html'\n    };\n\n    return directive;\n  }\n})();\n","(function() {\n    'use strict';\n\n  angular.module('app')\n    .factory('predictionMachinesService', predictionMachinesService);\n\n  predictionMachinesService.$inject = ['corelationRegisterService',\n                                        'localHistoryTableService'];\n  function predictionMachinesService(corelationRegisterService,\n                                    localHistoryTableService) {\n      var service = {\n          numOfMachines: null,\n          sizeOfMachines: 2,\n          value: [],\n\n          setMachineSize: setMachineSize,\n          getCurrentPrediction: getCurrentPrediction,\n          updatePredictions: updatePredictions\n      };\n\n      return service;\n\n      function setMachineSize(size1, size2) {\n          size1 = size1 || corelationRegisterService.size;\n          size2 = size2 || localHistoryTableService.size;\n\n          service.numOfMachines = Math.pow(2, size1 + size2);\n          service.value = [];\n\n          var i = 0;\n          while (i < service.numOfMachines) {\n              service.value[i++] = [1, 0];\n          }\n      }\n\n      function updateMachine(machineIndex, value) {\n          var machineValue = parseInt(service.value[machineIndex].join(''), 2);\n          var maxValue = Math.pow(2, 2) - 1;\n\n          if (value === 0 && \n            machineValue > 0) {\n              machineValue -= 1;\n          } else if (value === 1 &&\n                    machineValue < maxValue){\n              machineValue += 1;\n          }\n\n          var binaryValue = machineValue.toString(2);\n          service.value[machineIndex] = padWithZeroes(binaryValue, service.sizeOfMachines).split('');\n\n          return service.value;\n      }\n\n      function getCurrentPrediction() {\n          var localHistoryIndex = corelationRegisterService.getRegisterValue();\n          var predictionMachineIndex = localHistoryTableService.getLocalHistoryValue(localHistoryIndex);\n          var predictionValString = service.value[predictionMachineIndex].join('');\n          var predictionValue = parseInt(predictionValString, 2);\n          return predictionValue >= 2 ? true : false; \n      }\n\n      function padWithZeroes(value, howMany) {\n\t\t\tvar zeroes = '';\n            for (var i = 0; i < howMany; i++) {\n\t\t\t\tzeroes += '0';\n\t\t\t}\n\n\t\t\treturn (zeroes + value).slice(-howMany);\n\t\t}\n\n      function updatePredictions(value) {\n          var localHistoryIndex = corelationRegisterService.getRegisterValue();\n          var predictionMachineIndex = localHistoryTableService.getLocalHistoryValue(localHistoryIndex);\n\n          updateMachine(predictionMachineIndex, value);\n          localHistoryTableService.shiftWithValue(localHistoryIndex, value);\n          corelationRegisterService.shiftWithValue(value);\n      }\n  }\n})();\n","(function(/* BrowserSync-Brunch */) {\n  var url = \"//\" + location.hostname + \":3000/browser-sync/browser-sync-client.2.1.6.js\";\n  var bs = document.createElement(\"script\");\n  bs.type = \"text/javascript\"; bs.async = true; bs.src = url;\n  var s = document.getElementsByTagName(\"script\")[0];\n  s.parentNode.insertBefore(bs, s);\n})();"]}