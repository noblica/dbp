{"version":3,"sources":["app/TestModule/test.module.js","app/app.js","app/core/core.module.js","app/core/pipeline/pipeline.module.js","app/TestModule/test.controller.js","app/app.controller.js","app/codeInput/ALU.service.js","app/codeInput/codeInput.controller.js","app/codeInput/codeInput.directive.js","app/core/common.service.js","app/core/jmpInstruction.service.js","app/core/label.service.js","app/core/pc.service.js","app/core/pipeline/EX.model.js","app/core/pipeline/EX.service.js","app/core/pipeline/ID.model.js","app/core/pipeline/ID.service.js","app/core/pipeline/IF.model.js","app/core/pipeline/IF.service.js","app/core/pipeline/WB.model.js","app/core/pipeline/WB.service.js","app/core/pipeline/core.constants.js","app/core/register.service.js","app/core/speculative/speculative.model.js","app/core/speculative/speculative.service.js","app/corelationRegister/corelationRegister.controller.js","app/corelationRegister/corelationRegister.directive.js","app/corelationRegister/corelationRegister.service.js","app/localHistoryTable/localHistoryTable.controller.js","app/localHistoryTable/localHistoryTable.directive.js","app/localHistoryTable/localHistoryTable.service.js","app/predictionMachines/predictionMachines.controller.js","app/predictionMachines/predictionMachines.directive.js","app/predictionMachines/predictionMachines.service.js","node_modules/browser-sync-brunch/lib/vendor/browser-sync-injector.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrCA;AACA;AACA;AACA;AACA;AACA;ACLA;AACA;AACA;AACA;AACA;AACA;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CCnOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnEA;AACA;AACA;AACA;AACA;AACA;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChNA;AACA;AACA;AACA;AACA;AACA;AACA","file":"js/app.js","sourcesContent":["(function() {\r\n    'use strict';\r\n    \r\n    angular.module('test', []);\r\n})();","(function() {\r\n    'use strict';\r\n    \r\n    angular.module('app', ['ui.router',\r\n                            'ui.bootstrap',\r\n                            'ngAnimate',\r\n                            'core', \r\n                            'pipeline',\r\n                           'test'])\r\n        .config(routeConfiguration);\r\n    \r\n    routeConfiguration.$inject = ['$stateProvider', '$urlRouterProvider'];\r\n    function routeConfiguration($stateProvider, $urlRouterProvider) {\r\n        $stateProvider\r\n            .state('app', {\r\n                abstract: true,\r\n                controller: 'AppController',\r\n                controllerAs: 'app',\r\n                template: '<ui-view></ui-view>'\r\n            })\r\n            .state('app.home', {\r\n                url: '',\r\n                controller: 'TestController',\r\n                controllerAs: 'vm',\r\n                templateUrl: 'app/TestModule/test.html'\r\n            });\r\n        \r\n        $urlRouterProvider\r\n            .when('', goHome)\r\n            .when('/', goHome)\r\n            .otherwise('/error/404');\r\n        \r\n        goHome.$inject = ['$state'];\r\n        function goHome($state) {\r\n            $state.go('app.home');\r\n        }\r\n    }\r\n})();","(function() {\r\n    'use strict';\r\n\r\n    angular.module('core', []);\r\n    \r\n})();","(function() {\r\n    'use strict';\r\n\r\n    angular.module('pipeline', []);\r\n    \r\n})();","(function() {\r\n    'use strict';\r\n\r\n    angular.module('test')\r\n        .controller('TestController', TestController);\r\n\r\n    TestController.$inject = ['predictionMachinesService'];\r\n    function TestController(predictionMachinesService) {\r\n        var vm = this;\r\n\r\n        vm.corelationRegisterCollapse = false;\r\n        vm.localHistoryCollapse = true;\r\n        vm.predictionMachinesCollapse = true;\r\n        vm.predictionMachinesService = predictionMachinesService;\r\n\r\n        vm.toggleLocalHistory = toggleLocalHistory;\r\n\r\n        activate();\r\n\r\n        function activate() {}\r\n\r\n        function toggleLocalHistory(historyHandler) {\r\n            vm.localHistoryCollapse = !vm.localHistoryCollapse;\r\n            console.log(vm.localHistoryCollapse);\r\n        }\r\n    }\r\n})();\r\n","(function() {\r\n    'use strict';\r\n    \r\n    angular.module('app')\r\n        .controller('AppController', AppController);\r\n    \r\n    AppController.$inject = [];\r\n    function AppController() {\r\n        var vm = this;\r\n        \r\n        activate();\r\n        \r\n        function activate() {\r\n            console.log('Layout controller loaded!');    \r\n        }\r\n    }\r\n})();","/**\r\n * A service that decodes the operation,\r\n * and actually executes it, and also sets the corresponding flags.\r\n */\r\n\r\n(function() {\r\n  'use strict';\r\n\r\n  /*jshint bitwise: false*/\r\n  /*jshint maxcomplexity: false*/\r\n  angular.module('app')\r\n    .factory('aluService', aluService);\r\n\r\n  aluService.$inject = ['registerService'];\r\n  function aluService(registerService) {\r\n    var service = {\r\n        flags: {\r\n            ZF: false,\r\n            CF: false,\r\n            OF: false,\r\n            SF: false\r\n        },\r\n        a: 0,\r\n        aRegName: '',\r\n        b: 0,\r\n        bRegName: '',\r\n        cmpResult: 0,\r\n        maxValue: Math.pow(2, 16) - 1,\r\n       \r\n        maxValueSigned: Math.pow(2, 15) - 1,\r\n        bitSize: 15,\r\n\r\n        compareAndSetFlags: compareAndSetFlags\r\n\r\n        // cmpResult values:\r\n        // 0 - Previous comparison result is a = b\r\n        // <0 - Previous comparison is a < b\r\n        // >0 - Previous comparison is a > b\r\n    };\r\n\r\n    return service;\r\n\r\n    /**\r\n     * Helper function for setiting the maximum value allowed.\r\n     * The value should be set in bits.\r\n     */\r\n    function setMaxValue(newBitValue) {\r\n        service.maxValue = Math.pow(2, newBitValue) - 1;\r\n        service.maxValueSigned = Math.pow(2, newBitValue - 1) - 1;\r\n        return service.maxValue;\r\n    }\r\n    \r\n    function setRegNamesAndValues(value1, value2) {\r\n        \r\n        // service.a = registerService.getValueOfReg(value1) || service.a;\r\n        service.a = registerService.getValueOfReg(value1);\r\n        service.b = Number(value2) !== undefined ? \r\n                    Number(value2) :\r\n                    service.b;\r\n        \r\n        /**\r\n         * If the second operator is not a number,\r\n         * it can only be a name of a register.\r\n         * So we fetch the value from that register, and use it from here on out.\r\n         */\r\n        if (isNaN(value2)) {\r\n            service.bRegName = value2;\r\n            service.b = registerService.getValueOfReg(value2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Decodes the operation using switch-case,\r\n     * assigns the parsed values to the service,\r\n     * executes the operation, and sets the flags.\r\n     */\r\n    function compareAndSetFlags(newA, newB, operation) {\r\n        \r\n        /**\r\n         * Get the values.\r\n         * If they aren't being passed in, assign the previous values,\r\n         * to the temporary variables\r\n         */\r\n        setRegNamesAndValues(newA, newB);\r\n\r\n        var cmpResult = service.cmpResult;\r\n        var aSign = getSign(service.a);\r\n        var bSign = getSign(service.b);\r\n        var cmpSign = null;\r\n\r\n        var operationMap = {\r\n            'mov': mov,\r\n            'add': add,\r\n\r\n            'sub': sub,\r\n            'cmp': sub,\r\n\r\n            'mul': mul,\r\n            'div': div,\r\n            'and': and,\r\n            'or': or,\r\n            'xor': xor,\r\n            'test': test,\r\n            'not': not,\r\n            'end': end\r\n        };\r\n\r\n        service.cmpResult = operationMap[operation]();\r\n        return service.cmpResult;\r\n\r\n        function mov() {\r\n            registerService.setValueOfReg(service.aRegName, service.b);\r\n            cmpResult = service.b;\r\n\r\n            return cmpResult;\r\n        }\r\n\r\n        function add() {\r\n            cmpResult = service.a + service.b;\r\n\r\n            setCF(false);\r\n            setOF(false);\r\n\r\n            if (Math.abs(cmpResult) > service.maxValue) {\r\n                setCF(true);\r\n                cmpResult = truncateResult(cmpResult);\r\n            }\r\n\r\n            cmpSign = getSign(cmpResult);\r\n            if (signChanged(aSign, bSign, cmpSign)) {\r\n                    setOF(true);\r\n                }\r\n                \r\n            registerService.setValueOfReg(service.aRegName, cmpResult);\r\n\r\n            return cmpResult;\r\n        }\r\n\r\n        function sub() {\r\n            setCF(false);\r\n            setOF(false);\r\n            setZF(false);\r\n            \r\n            cmpResult = truncateResult(service.a - service.b);\r\n                            \r\n            if (service.b > service.a) {\r\n                setCF(true);\r\n            }\r\n\r\n            if (service.b === service.a) {\r\n                setZF(true);\r\n            }\r\n\r\n            cmpSign = getSign(cmpResult);\r\n\r\n            if (signChanged(aSign, bSign, cmpSign)) {\r\n                setOF(true);\r\n            }\r\n            \r\n            registerService.setValueOfReg(service.aRegName, cmpResult);\r\n\r\n            return cmpResult;\r\n        }\r\n\r\n        function mul() {\r\n            setCF(false);\r\n            setOF(false);\r\n            setZF(false);\r\n\r\n            cmpResult = service.a * service.b;\r\n\r\n            if (cmpResult === 0) {\r\n                setZF(true);\r\n            }\r\n\r\n            if (Math.abs(cmpResult) > service.maxValue) {\r\n                setCF(true);\r\n                cmpResult = truncateResult(cmpResult);\r\n            }\r\n\r\n            cmpSign = getSign(cmpResult);\r\n            if (signChanged(aSign, bSign, cmpSign)) {\r\n                    setOF(true);\r\n                }\r\n\r\n            return cmpResult;\r\n        }\r\n\r\n        function div() {\r\n            setOF(false);\r\n            \r\n            cmpResult = service.a / service.b;\r\n\r\n            if (cmpSign === Infinity) {\r\n                    setOF(true);\r\n                }\r\n\r\n            return cmpResult;\r\n        }\r\n\r\n        function and() {\r\n            cmpResult = service.a & service.b;\r\n            setSF(!!getSign(cmpResult));\r\n            registerService.setValueOfReg(service.aRegName, cmpResult);\r\n\r\n            return cmpResult;\r\n        }\r\n\r\n        function or() {\r\n            cmpResult = service.a | service.b;\r\n            setSF(!!getSign(cmpResult));\r\n            registerService.setValueOfReg(service.aRegName, cmpResult);\r\n\r\n            return cmpResult;\r\n        }\r\n\r\n        function xor() {\r\n            cmpResult = service.a ^ service.b;\r\n            setSF(!!getSign(cmpResult));\r\n            registerService.setValueOfReg(service.aRegName, cmpResult);\r\n\r\n            return cmpResult;\r\n\r\n        }\r\n\r\n        function test() {\r\n            setZF(false);\r\n            setSF(false);\r\n            \r\n            cmpResult = service.a & service.b;\r\n            \r\n            if (cmpResult === 0) {\r\n                setZF(true);\r\n            }\r\n            \r\n            setSF(!!getSign(cmpResult));\r\n\r\n            return cmpResult;\r\n        }\r\n\r\n        function not() {\r\n            cmpResult = ~service.a;\r\n            registerService.setValueOfReg(service.aRegName, cmpResult);\r\n\r\n            return cmpResult;\r\n        }\r\n\r\n        function end() {\r\n            console.log('end reached!');\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * A helper funtion for checking if the sign has changed.\r\n     * Useful if called after the operation was executed.\r\n     * It needs both operator signs, and the result sign.\r\n     */\r\n    function signChanged(aSign, bSign, cmpSign) {\r\n        return ((aSign === bSign) &&\r\n                (cmpSign !== aSign));\r\n    }\r\n\r\n    /**\r\n     * A helper function for fetching the sign of a passed in number.\r\n     * The number is truncated (just in case),\r\n     * converted to it's binary form,\r\n     * split, so that each number is an element in an array,\r\n     * reversed (because fetching the [0] element of the array doesn't always represent it's sign),\r\n     * and it's last bit is fetched (which, when it's reversed, represents the number)\r\n     * \r\n     * The value will be 0 if the number is > 0, or 1 if the number is < 0.\r\n     */\r\n    function getSign(number) {\r\n        var bitSize = service.bitSize;\r\n        var truncatedValue = truncateResult(number);\r\n        var bitValue = truncatedValue.toString(2);\r\n        var sign = Number(bitValue.split('').reverse()[bitSize]);\r\n\r\n        return sign ? sign : 0;\r\n    }\r\n    \r\n    /**\r\n     * A function that returns truncated value of the number passed in.\r\n     */\r\n    function truncateResult(result) {\r\n        return Number(result) & service.maxValue;\r\n    }\r\n\r\n    // Function for setting the zero flag\r\n    function setZF(newZFValue) {\r\n        service.flags.ZF = newZFValue === undefined ?\r\n                        (service.cmpResult === 0) :\r\n                        newZFValue;\r\n        return service.flags;\r\n    }\r\n\r\n    // Function for setting the carry flag\r\n    function setCF(newCFValue) {\r\n        service.flags.CF = newCFValue === undefined ?\r\n                        service.flags.CF :\r\n                        newCFValue;\r\n        return service.flags;\r\n    }\r\n\r\n    // Function for setting the overflow flag\r\n    function setOF(newOFValue) {\r\n        service.flags.OF = newOFValue;\r\n\r\n        if (newOFValue === undefined) {\r\n            service.flags.OF = newOFValue === undefined ? \r\n                                service.flags.OF :\r\n                                newOFValue;\r\n        }\r\n        return service.flags;\r\n    }\r\n\r\n    // Sign/Negative flag\r\n    function setSF(newSFValue) {\r\n        service.flags.SF = newSFValue ||\r\n                        (service.cmpResult < 0) ||\r\n                        (service.cmpResult > service.maxValue);\r\n        return service.flags;\r\n    }\r\n  }\r\n})();\r\n","(function () {\r\n  'use strict';\r\n\r\n  angular.module('app')\r\n    .controller('CodeInputController', CodeInputController);\r\n\r\n  // jshint maxparams:15\r\n\r\n  CodeInputController.$inject = ['IFService',\r\n    'IFModel',\r\n    'IDService',\r\n    'IDModel',\r\n    'EXService',\r\n    'EXModel',\r\n    'WBService',\r\n    'WBModel',\r\n    'labelService',\r\n    'pcService',\r\n    'common',\r\n    '$interval',\r\n    'speculativeService',\r\n    'speculativeModel',\r\n    'jmpInstructionService'];\r\n\r\n  function CodeInputController(IFService,\r\n    IFModel,\r\n    IDService,\r\n    IDModel,\r\n    EXService,\r\n    EXModel,\r\n    WBService,\r\n    WBModel,\r\n    labelService,\r\n    pcService,\r\n    common,\r\n    $interval,\r\n    speculativeService,\r\n    speculativeModel,\r\n    jmpInstructionService) {\r\n    var vm = this;\r\n\r\n    vm.codeInput = 'mov ax, 0\\nmov bx, 2\\nl1:\\nadd ax, 1\\ncmp ax, bx\\njl l1\\nend';\r\n    vm.stepByStep = false;\r\n    vm.codeArray = [];\r\n    vm.pipelineStarted = false;\r\n    vm.endReached = false;\r\n    vm.trapFlag = false;\r\n\r\n    vm.IFModel = IFModel;\r\n    vm.IDModel = IDModel;\r\n    vm.EXModel = EXModel;\r\n    vm.WBModel = WBModel;\r\n    vm.common = common;\r\n\r\n    vm.doPrediction = doPrediction;\r\n    vm.goToNextBranchInstruction = goToNextBranchInstruction;\r\n\r\n    function doPrediction(codeInput) {\r\n      var codeSplitByLine = codeInput.split('\\n'),\r\n        codeArray = removeJustNewlines(codeSplitByLine);\r\n\r\n      speculativeModel.buffer = [];\r\n      vm.codeArray = labelService.setAndRemoveLabelsFromCodeArray(codeArray);\r\n\r\n      common.pipelineStarted = true;\r\n\r\n      // Initial PC value (not yet started)\r\n      pcService.pc = -1;\r\n\r\n      if (vm.stepByStep) {\r\n        pcService.setNewPc();\r\n        parseAll(pcService.pc, vm.codeArray);\r\n      } else {\r\n        setIterationInterval(vm.codeArray);\r\n      }\r\n    }\r\n\r\n    function goToNextBranchInstruction(codeArray) {\r\n      common.pipelineInterval = $interval(function () {\r\n      // common.pipelineActive = true;\r\n\r\n      // while (common.pipelineActive && !shouldStopExecution(codeArray)) {\r\n      // common.pipelineActive = false;\r\n      // if (common.pipelineActive) {\r\n\r\n        if (jmpOrGenFlagInstructionInEx() &&\r\n          vm.trapFlag) {\r\n          $interval.cancel(common.pipelineInterval);\r\n\r\n          vm.trapFlag = false;\r\n        } else {\r\n          vm.trapFlag = true;\r\n\r\n          iterateThePipeline(pcService.pc, codeArray)\r\n            .then(function () {\r\n\r\n              if (shouldStopExecution(codeArray)) {\r\n                $interval.cancel(common.pipelineInterval);\r\n                common.flushPipeline();\r\n                speculativeService.clear();\r\n                common.flushPipeline(false, false, false, true);\r\n                common.pipelineStarted = false;\r\n                common.pipelineActive = false;\r\n              }\r\n            });\r\n        }\r\n      }, 10);\r\n    }\r\n\r\n    function jmpOrGenFlagInstructionInEx() {\r\n      return EXModel.instructionsInEX.some(function (instruction) {\r\n        return jmpInstructionService.isJmpInstruction(instruction.operation) ||\r\n          jmpInstructionService.isFlagGenInstruction(instruction.operation);\r\n      });\r\n    }\r\n\r\n    function setIterationInterval(codeArray) {\r\n      common.pipelineInterval = $interval(function () {\r\n      // if (common.pipelineActive) {\r\n\r\n      iterateThePipeline(pcService.pc, codeArray)\r\n        .then(function () {\r\n\r\n          if (shouldStopExecution(codeArray)) {\r\n            $interval.cancel(common.pipelineInterval);\r\n            common.flushPipeline();\r\n            speculativeService.clear();\r\n            common.flushPipeline(false, false, false, true);\r\n            common.pipelineStarted = false;\r\n            common.pipelineActive = false;\r\n          } \r\n          // else {\r\n          //   setIterationInterval(codeArray);\r\n          // }\r\n          }, 10);\r\n        });\r\n      // }\r\n    }\r\n\r\n    function shouldStopExecution(codeArray) {\r\n      var noMoreInPipeline = common.isPipelineEmpty(),\r\n      noMoreInSpeculative = speculativeService.modelIsEmpty(),\r\n      endReached = WBService.endReached;\r\n\r\n      return (noMoreInPipeline && noMoreInSpeculative && endReached);\r\n    }\r\n\r\n    function removeJustNewlines(arrayWithNewlines) {\r\n      var arrayWithoutNewlines = arrayWithNewlines.filter(function (value) {\r\n        return value !== '';\r\n      });\r\n\r\n      return arrayWithoutNewlines;\r\n    }\r\n\r\n    function iterateThePipeline(pc, codeArray, howMany) {\r\n\r\n      return pipeThroughAll()\r\n        .then(function () {\r\n          pcService.setNewPc();\r\n          var parsePromise = parseAll(pcService.pc, codeArray, howMany);\r\n          return parsePromise;\r\n        });\r\n    }\r\n\r\n    function parseAll(pc, codeArray, howMany) {\r\n      return IFService.parse(pc, codeArray, 1)\r\n        .then(IDService.parse)\r\n        .then(EXService.parse)\r\n        .then(WBService.parse)\r\n        .then(function (response) {\r\n          console.log(response);\r\n        });\r\n    }\r\n\r\n    function pipeThroughAll() {\r\n      return WBService.pipeThrough()\r\n        .then(EXService.pipeThrough)\r\n        .then(IDService.pipeThrough)\r\n        .then(IFService.pipeThrough);\r\n    }\r\n\r\n  }\r\n})();\r\n\r\n// Following are the conditional jump instructions used on signed data used for arithmetic operations −\r\n//\r\n// Instruction\tDescription\tFlags tested\r\n// JE/JZ\tJump Equal or Jump Zero\tZF\r\n// JNE/JNZ\tJump not Equal or Jump Not Zero\tZF\r\n// JG/JNLE\tJump Greater or Jump Not Less/Equal\tOF, SF, ZF\r\n// JGE/JNL\tJump Greater/Equal or Jump Not Less\tOF, SF\r\n// JL/JNGE\tJump Less or Jump Not Greater/Equal\tOF, SF\r\n// JLE/JNG\tJump Less/Equal or Jump Not Greater\tOF, SF, ZF\r\n// Following are the conditional jump instructions used on unsigned data used for logical operations −\r\n//\r\n// Instruction\tDescription\tFlags tested\r\n// JE/JZ\tJump Equal or Jump Zero\tZF\r\n// JNE/JNZ\tJump not Equal or Jump Not Zero\tZF\r\n// JA/JNBE\tJump Above or Jump Not Below/Equal\tCF, ZF\r\n// JAE/JNB\tJump Above/Equal or Jump Not Below\tCF\r\n// JB/JNAE\tJump Below or Jump Not Above/Equal\tCF\r\n// JBE/JNA\tJump Below/Equal or Jump Not Above\tAF, CF\r\n// The following conditional jump instructions have special uses and check the value of flags −\r\n//\r\n// Instruction\tDescription\tFlags tested\r\n// JXCZ\tJump if CX is Zero\tnone\r\n// JC\tJump If Carry\tCF\r\n// JNC\tJump If No Carry\tCF\r\n// JO\tJump If Overflow\tOF\r\n// JNO\tJump If No Overflow\tOF\r\n// JP/JPE\tJump Parity or Jump Parity Even\tPF\r\n// JNP/JPO\tJump No Parity or Jump Parity Odd\tPF\r\n// JS\tJump Sign (negative value)\tSF\r\n// JNS\tJump No Sign (positive value)\tSF\r\n// The syntax for the J<condition> set of instructions −\r\n//\r\n// Example,\r\n//\r\n// CMP\tAL, BL\r\n// JE\tEQUAL\r\n// CMP\tAL, BH\r\n// JE\tEQUAL\r\n// CMP\tAL, CL\r\n// JE\tEQUAL\r\n// NON_EQUAL: ...\r\n// EQUAL: ...\r\n","(function() {\r\n  'use strict';\r\n\r\n  angular.module('app')\r\n    .directive('codeInput', codeInput);\r\n\r\n  codeInput.$inject = [];\r\n  function codeInput() {\r\n    var directive = {\r\n      restrict: 'E',\r\n      controller: 'CodeInputController',\r\n      controllerAs: 'ci',\r\n      templateUrl: 'app/codeInput/code-input.html'\r\n    };\r\n\r\n    return directive;\r\n  }\r\n})();\r\n","(function() {\r\n    'use strict';\r\n\r\n    angular.module('core')\r\n        .factory('common', common);\r\n\r\n    common.$inject = ['IFModel', \r\n                      'IDModel',\r\n                      'EXModel',\r\n                      'WBModel'];\r\n                      \r\n    function common(IFModel, \r\n                       IDModel,\r\n                       EXModel,\r\n                       WBModel) {\r\n                           \r\n        var service = {\r\n            pipelineStarted: false,\r\n            pipelineActive: false,\r\n            \r\n            flushPipeline: flushPipeline,\r\n            isPipelineEmpty: isPipelineEmpty,\r\n            instructionToText: instructionToText\r\n        };\r\n\r\n        return service;\r\n        \r\n        function flushPipeline(flushIf, flushId, flushEx, flushWb) {\r\n      \r\n            if (flushIf === undefined) {\r\n                IFModel.flush();\r\n                IDModel.flush();\r\n                EXModel.flush();\r\n            } else {\r\n            \r\n                if (flushIf) {\r\n                    IFModel.flush();\r\n                }\r\n                \r\n                if (flushId) {\r\n                    IDModel.flush();\r\n                }\r\n                \r\n                if (flushEx) {\r\n                    EXModel.flush();\r\n                }\r\n                \r\n                if (flushWb) {\r\n                    WBModel.flush();\r\n                }\r\n            }\r\n        }\r\n\r\n        function isPipelineEmpty() {\r\n            return IFModel.instructionsInIF.length === 0 &&\r\n                    IDModel.instructionsInID.length === 0 &&\r\n                    EXModel.instructionsInEX.length === 0 &&\r\n                    WBModel.instructionsInWB.length === 0;\r\n        }\r\n\r\n        function instructionToText(instructionObject) {\r\n            var firstOperatorExists = instructionObject.firstOperator !== (undefined || null);\r\n            var secondOperatorExists = instructionObject.secondOperator !== (undefined || null); \r\n\r\n            return instructionObject.operation + ' ' +\r\n            (firstOperatorExists ?\r\n             instructionObject.firstOperator :\r\n             '') +\r\n             (secondOperatorExists ? \r\n             (', ' + instructionObject.secondOperator) :\r\n             (''));\r\n        }\r\n    }\r\n})();","(function() {\r\n    'use strict';\r\n    \r\n  /*jshint maxcomplexity: false*/\r\n    angular.module('core')\r\n        .factory('jmpInstructionService', jmpInstructionService);\r\n\r\n    jmpInstructionService.$inject = ['aluService'];\r\n    function jmpInstructionService (aluService) {\r\n        var service = {\r\n            jmpInstructions: [],\r\n            isJmpInstruction: isJmpInstruction,\r\n            isFlagGenInstruction: isFlagGenInstruction,\r\n            checkBranchCondition: checkBranchCondition\r\n        };\r\n        \r\n        activate();\r\n\r\n        return service;\r\n        \r\n        function activate() {\r\n            service.jmpInstructions = ['jmp', 'je', 'jz', 'jne',\r\n                                        'jnz', 'jg', 'jnle', 'jge',\r\n                                        'jnl', 'jl', 'jnge', 'jle',\r\n                                        'jng'];\r\n            service.flagGenInstructions = ['test', 'cmp'];\r\n        }\r\n        \r\n        function isJmpInstruction(operation) {\r\n            return service.jmpInstructions.indexOf(operation) !== -1;\r\n        }\r\n\r\n        function isFlagGenInstruction(operation) {\r\n            return service.flagGenInstructions.indexOf(operation) !== -1;            \r\n        }\r\n        \r\n        function checkBranchCondition(operation) {\r\n            var aluFlags = aluService.flags;\r\n            var aluFlagMap = {\r\n                'jmp': true,\r\n\r\n                'je': aluFlags.ZF,\r\n                'jz': aluFlags.ZF,\r\n\r\n                'jne': !aluFlags.ZF,\r\n                'jnz': !aluFlags.ZF,\r\n\r\n                'jg': (!aluFlags.ZF && (aluFlags.SF === aluFlags.OF)),\r\n                'jnle': (!aluFlags.ZF && (aluFlags.SF === aluFlags.OF)),\r\n\r\n                'jge': aluFlags.SF === aluFlags.OF,\r\n                'jnl': aluFlags.SF === aluFlags.OF,\r\n\r\n                'jl': (aluFlags.SF !== aluFlags.OF),\r\n                'jnge': (aluFlags.SF !== aluFlags.OF),\r\n\r\n                'jle': (aluFlags.ZF) || (aluFlags.SF !== aluFlags.OF),\r\n                'jng': (aluFlags.ZF) || (aluFlags.SF !== aluFlags.OF)\r\n            };\r\n\r\n            return aluFlagMap[operation];\r\n        }\r\n    }\r\n})();\r\n","(function() {\r\n    'use strict';\r\n\r\n    angular.module('core')\r\n        .factory('labelService', labelService);\r\n\r\n    labelService.$inject = [];\r\n    function labelService() {\r\n        var service = {\r\n            labelArray: [],\r\n            \r\n            getAddress: getAddress,\r\n            setLabelAddress: setLabelAddress,\r\n            setAndRemoveLabelsFromCodeArray: setAndRemoveLabelsFromCodeArray\r\n        };\r\n\r\n        return service;\r\n        \r\n        function setLabelAddress(label, address) {\r\n            var objectToPush = {};\r\n            objectToPush[label.toLowerCase()] = address;\r\n            service.labelArray.push(objectToPush);\r\n        }\r\n        \r\n        function getAddress(label) {\r\n            var labelObjectToReturn = null;\r\n                        \r\n            service.labelArray.some(function(labelObject) {\r\n                if (labelObject[label] !== undefined) {\r\n                    labelObjectToReturn = labelObject;\r\n                    return true;\r\n                }\r\n            });\r\n            \r\n            return labelObjectToReturn[label];\r\n        }\r\n        \r\n        function setAndRemoveLabelsFromCodeArray(codeArray) {\r\n            var codeArrayToReturn = codeArray;\r\n            var index = 0;\r\n            \r\n            while (index < codeArray.length){\r\n                var codeString = codeArray[index];\r\n                \r\n                if (codeString.indexOf(':') !== -1) {\r\n                    var label = codeString.slice(0, codeString.indexOf(':'));\r\n                    \r\n                    codeArrayToReturn.splice(index, 1);\r\n                    setLabelAddress(label, index);\r\n                }\r\n                else {\r\n                    index++;\r\n                }\r\n            }            \r\n            return codeArrayToReturn;\r\n        }\r\n    }\r\n})();","(function() {\r\n    'use strict';\r\n\r\n    angular.module('core')\r\n        .factory('pcService', pcService);\r\n\r\n    pcService.$inject = [];\r\n    function pcService() {\r\n        var service = {\r\n            pc: -1,\r\n            branchesPredictedTaken: [],\r\n            overridePc: null,\r\n\r\n            setNewPc: setNewPc,\r\n            getLastBitsOfPc: getLastBitsOfPc\r\n        };\r\n\r\n        return service;\r\n\r\n        function setNewPc() {\r\n\r\n            service.pc += 1;\r\n            if (service.overridePc !== null) {\r\n                service.pc = service.overridePc;\r\n                service.overridePc = null;\r\n            }\r\n        }\r\n\r\n        function getLastBitsOfPc(numOfBits, pcToUse) {\r\n            var pcInBits = pcToUse ? pcToUse.toString(2) : service.pc.toString(2),\r\n            lastBits = pcInBits.slice(-numOfBits);\r\n\r\n            return parseInt(lastBits, 2);\r\n        }\r\n    }\r\n})();\r\n","(function() {\r\n    'use strict';\r\n\r\n    angular.module('core')\r\n        .factory('EXModel', EXModel);\r\n\r\n    EXModel.$inject = [];\r\n    function EXModel() {\r\n        var service = {\r\n            currentPc: null,\r\n            returnPromise: null,\r\n            nextPredictionFalse: false,\r\n            instructionsInEX: [],\r\n            writeBackResults: [],\r\n\r\n            flush: flush\r\n        };\r\n\r\n        return service;\r\n  \r\n        function flush() {\r\n            service.currentPc = 0;\r\n            service.instructionsInEX = [];\r\n            service.writeBackResults = [];\r\n            var objectToResolve = {\r\n                currentPc: service.currentPc,\r\n                instructionSet: service.instructionsInEX,\r\n                writeBackResults: service.writeBackResults\r\n            };\r\n\r\n            // Resolving, so that the pipeline doesn't stall,\r\n            // even though we're flushing.\r\n            service.returnPromise.resolve(objectToResolve);\r\n        }\r\n    }\r\n})();\r\n","(function () {\r\n    'use strict';\r\n\r\n    angular.module('core')\r\n        .factory('EXService', EXService);\r\n    //jshint maxparams: 15\r\n    EXService.$inject = ['$q',\r\n        'aluService',\r\n        'jmpInstructionService',\r\n        'labelService',\r\n        'pcService',\r\n        'EXModel',\r\n        'WBService',\r\n        'common',\r\n        'speculativeModel',\r\n        'speculativeService',\r\n        'predictionMachinesService',\r\n        'corelationRegisterService',\r\n        'localHistoryTableService',\r\n        'Math'];\r\n    function EXService($q,\r\n        aluService,\r\n        jmpInstructionService,\r\n        labelService,\r\n        pcService,\r\n        EXModel,\r\n        WBService,\r\n        common,\r\n        speculativeModel,\r\n        speculativeService,\r\n        predictionMachinesService,\r\n        corelationRegisterService,\r\n        localHistoryTableService,\r\n        Math) {\r\n\r\n        // var flag = true;\r\n        var service = {\r\n            parse: parse,\r\n            pipeThrough: pipeThrough,\r\n            parseJumpInstruction: parseJumpInstruction\r\n        };\r\n\r\n        return service;\r\n\r\n        /**\r\n         * Set the current PC to the service, from the passed in object,\r\n         * set the array instructions to the service,\r\n         * and initiate the write back array to empty.\r\n         * \r\n         * Decodes the newley assigned instructions,\r\n         * and return a promise. \r\n         */\r\n        function parse(objectFromId) {\r\n\r\n            EXModel.currentPc = objectFromId.currentPc;\r\n            EXModel.instructionsInEX = objectFromId.instructionSet;\r\n            EXModel.writeBackResults = [];\r\n\r\n            decodeInstructions(EXModel.instructionsInEX);\r\n            decreaseDelay();\r\n            EXModel.returnPromise = $q.defer();\r\n\r\n            return EXModel.returnPromise.promise;\r\n        }\r\n\r\n        /**\r\n         * Parses the branch instruction,\r\n         * calculates the actual value(generates a flag),\r\n         * and then it compares it to the prediction.\r\n         * \r\n         * Depending on the prediction, we need to handle things differently.\r\n         */\r\n        function parseJumpInstruction(instruction, index) {\r\n            var branchTaken = jmpInstructionService.checkBranchCondition(instruction.operation),\r\n                labelAddress = labelService.getAddress(instruction.firstOperator),\r\n                currentOperationPc = EXModel.currentPc + index,\r\n                branchPredictedIndex = pcService.branchesPredictedTaken.indexOf(currentOperationPc),\r\n                delay = getRandomDelay(),\r\n                currentPrediction = predictionMachinesService.getCurrentPrediction(currentOperationPc);\r\n\r\n            /**\r\n             * Probably should remember the PC that generates the flag.\r\n             * TODO: Do that!\r\n             */\r\n            var branchInfo = {\r\n                pc: currentOperationPc,\r\n                jmpToPc: labelAddress,\r\n                delay: delay,\r\n                predictedValue: currentPrediction ? 1 : 0,\r\n                calculatedValue: branchTaken ? 1 : 0\r\n            },\r\n                corelationRegister = corelationRegisterService.getCopy(),\r\n                predictedArray = speculativeModel.formPredictedArray(speculativeModel.buffer),\r\n\r\n                localHistoryIndex = parseInt(corelationRegister.concat(predictedArray).join(''), 2),\r\n                useCor = corelationRegisterService.useCor,\r\n                useLht = localHistoryTableService.useLht;\r\n                \r\n                if(!useCor && useLht) {\r\n                    localHistoryIndex = \r\n                        pcService.getLastBitsOfPc(localHistoryTableService.numOfPcBits, currentOperationPc);\r\n                }\r\n                var localHistoryArray = localHistoryTableService.getCopyOfLocalHistoryArrayFor(localHistoryIndex),\r\n                predictionMachineIndex = localHistoryTableService.getLocalHistoryValue(localHistoryIndex),\r\n                predictionMachineValue = predictionMachinesService.getCopyOfMachine(predictionMachineIndex),\r\n\r\n                predictionOverrides = {\r\n                    localHistoryIndex: localHistoryIndex,\r\n                    localHistoryArray: localHistoryArray,\r\n                    predictionMachineIndex: predictionMachineIndex,\r\n                    predictionMachineValue: predictionMachineValue\r\n                };\r\n                \r\n            // Also, update all the predictions, except the ones at the corelation register.\r\n            predictionMachinesService.updatePredictionsExceptCorelation(branchInfo.predictedValue, branchInfo.pc);\r\n\r\n            speculativeService.createNewBranchBuffer(branchInfo, predictionOverrides);\r\n\r\n            speculativeModel.addingToSpeculative = true;\r\n        }\r\n\r\n        function calculateBranchInstruction(branchBufferObject) {\r\n            var predictedValue = branchBufferObject.branchInfo.predictedValue,\r\n                calculatedValue = branchBufferObject.branchInfo.calculatedValue,\r\n                branchPc = branchBufferObject.branchInfo.pc,\r\n                branchPredictedIndex = pcService.branchesPredictedTaken.indexOf(branchPc);\r\n\r\n            if (EXModel.nextPredictionFalse) {\r\n                calculatedValue = !calculatedValue;\r\n            }\r\n\r\n            // If branch should be taken, and it was predicted not taken \r\n            if (calculatedValue &&\r\n                !predictedValue) {\r\n                // Flush instructions\r\n                common.flushPipeline();\r\n\r\n                // Set the mispredicted flag to true\r\n                branchBufferObject.branchInfo.mispredicted = true;\r\n\r\n                // Set new PC\r\n                // pcService.pc = labelAddress;\r\n                branchBufferObject.branchInfo.mispredictionPc = branchBufferObject.branchInfo.jmpToPc;\r\n\r\n                branchBufferObject.branchInfo.predictedValue = branchBufferObject.branchInfo.calculatedValue;\r\n\r\n                // The execution loop needs to be broken \r\n                return true;\r\n            }\r\n\r\n            // If branch should be taken, and it was predicted taken \r\n            else if (calculatedValue &&\r\n                predictedValue) {\r\n\r\n                // Remove the prediction from the list of predicted taken\r\n                pcService.branchesPredictedTaken.splice(branchPredictedIndex, 1);\r\n\r\n                branchBufferObject.branchInfo.shouldCommit = true;\r\n            }\r\n\r\n            // If branch should not be taken, and it was predicted not taken \r\n            else if (!calculatedValue &&\r\n                !predictedValue) {\r\n\r\n                branchBufferObject.branchInfo.shouldCommit = true;\r\n            }\r\n\r\n            // If branch should not be taken, and it was predicted taken \r\n            else if (!calculatedValue &&\r\n                predictedValue) {\r\n\r\n                // Flush instructions in IF and ID\r\n                common.flushPipeline();\r\n\r\n                // Set the mispredicted flag to true\r\n                branchBufferObject.branchInfo.mispredicted = true;\r\n\r\n                branchBufferObject.branchInfo.mispredictionPc = branchPc + 1;\r\n\r\n                // Remove the prediction from the list of predicted taken\r\n                pcService.branchesPredictedTaken.splice(branchPredictedIndex, 1);\r\n\r\n                branchBufferObject.branchInfo.predictedValue = branchBufferObject.branchInfo.calculatedValue;\r\n\r\n\r\n                // The execution loop needs to be broken \r\n                return true;\r\n            }\r\n\r\n            // The execution loop should not be broken\r\n            return false;\r\n        }\r\n\r\n        function parseALUInstruction(instruction) {\r\n            EXModel.writeBackResults = executeInstructions(instruction);\r\n        }\r\n\r\n        /**\r\n         * Decrease the delay for calculation for all the stuff currently being calculated.\r\n         */\r\n        function decreaseDelay() {\r\n\r\n            speculativeModel.buffer.map(function (value, index) {\r\n                if (value.branchInfo.delay) {\r\n                    value.branchInfo.delay -= 1;\r\n                }\r\n\r\n                if (value.branchInfo.delay === 0) {\r\n                    value.branchInfo.calculated = true;\r\n                    calculateBranchInstruction(value);\r\n                    speculativeService.mergeAndCommitValues(value);\r\n                }\r\n                return value;\r\n            });\r\n\r\n            /**\r\n             * If no more values in speculative buffer, \r\n             * stop adding results to it.\r\n             */\r\n            if (speculativeModel.buffer.length === 0) {\r\n                speculativeModel.addingToSpeculative = false;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Helper function for getting the random delay.\r\n         * Between 4 and 40 cycles.\r\n         */\r\n        function getRandomDelay() {\r\n            return Math.floor((Math.random() * 40) + 4);\r\n        }\r\n\r\n        function decodeInstructions(instructionsToDecode) {\r\n\r\n            instructionsToDecode.some(function (operationObject, index) {\r\n                var operationFromId = operationObject.operation;\r\n                var isJmpInstruction = jmpInstructionService.isJmpInstruction(operationFromId);\r\n\r\n                if (isJmpInstruction) {\r\n                    var jmpTaken = parseJumpInstruction(operationObject, index);\r\n                    return jmpTaken;\r\n                } else {\r\n                    parseALUInstruction(operationObject);\r\n                }\r\n            });\r\n            return EXModel.instructionsInEX;\r\n        }\r\n\r\n        /**\r\n         * Create an object, which will be piped through to the next part in the pipeline.\r\n         * \r\n         * Passing the currentPc, \r\n         * the instruction array, \r\n         * the results to be written back,\r\n         * and resolve the returning promise with this object.\r\n         */\r\n        function pipeThrough() {\r\n\r\n            if (EXModel.returnPromise) {\r\n                var objectToPipe = {\r\n                    currentPc: EXModel.currentPc,\r\n                    instructionSet: EXModel.instructionsInEX,\r\n                    writeBackResults: EXModel.writeBackResults\r\n                };\r\n\r\n                EXModel.returnPromise.resolve(objectToPipe);\r\n                return EXModel.returnPromise.promise;\r\n            }\r\n\r\n            return $q.resolve();\r\n        }\r\n\r\n        function executeInstructions(instruction) {\r\n            var firstOperator = instruction.firstOperator;\r\n            var secondOperator = instruction.secondOperator;\r\n            var operation = instruction.operation;\r\n\r\n            var result = aluService.compareAndSetFlags(firstOperator, secondOperator, operation);\r\n            var writeBackObject = {\r\n                currentPc: EXModel.currentPc,\r\n                register: instruction.firstOperator,\r\n                result: result,\r\n                operation: operation\r\n            };\r\n\r\n            /**\r\n             * If instruction should be written back,\r\n             * then commit it to the speculative buffer.\r\n             * Else, don't commit it, because messes will happen.\r\n             */\r\n            if (speculativeModel.addingToSpeculative) {\r\n                if (WBService.shouldWriteBack(operation)) {\r\n                    speculativeService.addTo(firstOperator, result);\r\n                }\r\n            } else {\r\n                EXModel.writeBackResults.push(writeBackObject);\r\n            }\r\n\r\n            return EXModel.writeBackResults;\r\n        }\r\n    }\r\n})();","(function() {\r\n    'use strict';\r\n\r\n    angular.module('core')\r\n        .factory('IDModel', IDModel);\r\n\r\n    IDModel.$inject = [];\r\n    function IDModel() {\r\n        var service = {\r\n            currentPc: null,\r\n            returnPromise: null,\r\n            instructionsInID: [],\r\n            flush: flush\r\n        };\r\n\r\n        return service;\r\n\r\n        function flush() {\r\n            service.currentPc = 0;\r\n            service.instructionsInID = [];\r\n            var objectToResolve = {\r\n                currentPc: service.currentPc,\r\n                instructionSet: service.instructionsInID\r\n            };\r\n\r\n            // Resolving, so that the pipeline doesn't stall,\r\n            // even though we're flushing.\r\n            service.returnPromise.resolve(objectToResolve);\r\n        }\r\n    }\r\n})();\r\n","(function() {\r\n    'use strict';\r\n\r\n    angular.module('core')\r\n        .factory('IDService', IDService);\r\n\r\n    IDService.$inject = ['$q', 'IDModel'];\r\n    function IDService($q, IDModel) {\r\n        var service = {\r\n            parse: parse,\r\n            pipeThrough: pipeThrough,\r\n            decodeSingleInstruction: decodeSingleInstruction\r\n        };\r\n\r\n        return service;\r\n        \r\n        function parse(objectFromIf) {\r\n            IDModel.currentPc = objectFromIf.currentPc;\r\n            IDModel.instructionsInID = decodeInstructions(objectFromIf.instructionSet);\r\n            IDModel.returnPromise = $q.defer();\r\n            \r\n            return IDModel.returnPromise.promise;\r\n        }\r\n        \r\n        function pipeThrough() {\r\n            if (IDModel.returnPromise) {\r\n            \r\n                var objectToPipe = {\r\n                    currentPc: IDModel.currentPc,\r\n                    instructionSet: IDModel.instructionsInID\r\n                };\r\n                \r\n                IDModel.returnPromise.resolve(objectToPipe);\r\n                return IDModel.returnPromise.promise;\r\n            }\r\n            \r\n            return $q.resolve();\r\n        }\r\n\r\n        function decodeSingleInstruction(line) {\r\n            var removedCommaFromline = line.replace(',', '');\r\n                var splitBySpace = removedCommaFromline.split(' ');\r\n                \r\n                var decodedInstruction = {\r\n                    operation: splitBySpace[0].toLowerCase(),\r\n                    firstOperator: splitBySpace[1] === undefined ? \r\n                                                        null : \r\n                                                        splitBySpace[1].toLowerCase(),\r\n                    secondOperator: splitBySpace[2] === undefined ? \r\n                                                        null : \r\n                                                        splitBySpace[2].toLowerCase() \r\n                };\r\n\r\n            return decodedInstruction;\r\n        }\r\n        \r\n        function decodeInstructions(instructionsToDecode) {\r\n            var decodedInstructions = [];\r\n            \r\n            instructionsToDecode.forEach(function(line) {                \r\n                var newInstruction = decodeSingleInstruction(line);\r\n                \r\n                decodedInstructions.push(newInstruction);\r\n            });\r\n            return decodedInstructions;\r\n        }\r\n    }\r\n})();\r\n","(function() {\r\n    'use strict';\r\n\r\n    angular.module('core')\r\n        .factory('IFModel', IFModel);\r\n\r\n    IFModel.$inject = [];\r\n    function IFModel() {\r\n        var service = {\r\n            currentPc: null,\r\n            returnPromise: null,\r\n            instructionsInIF: [],\r\n\r\n            flush: flush\r\n        };\r\n\r\n        return service;\r\n\r\n        function flush() {\r\n            service.currentPc = 0;\r\n            service.instructionsInIF = [];\r\n            var objectToResolve = {\r\n                currentPc: service.currentPc,\r\n                instructionSet: service.instructionsInIF  \r\n            };\r\n\r\n            // Resolving, so that the pipeline doesn't stall,\r\n            // even though we're flushing.\r\n            service.returnPromise.resolve(objectToResolve);\r\n        }\r\n    }\r\n})();\r\n","(function() {\r\n    'use strict';\r\n\r\n    angular.module('core')\r\n        .factory('IFService', IFService);\r\n\r\n    IFService.$inject = ['$q', \r\n                        'IFModel',\r\n                        'IDService',\r\n                        'jmpInstructionService',\r\n                        'labelService',\r\n                        'pcService',\r\n                        'predictionMachinesService'];\r\n    function IFService($q,\r\n                        IFModel,\r\n                        IDService,\r\n                        jmpInstructionService,\r\n                        labelService,\r\n                        pcService,\r\n                        predictionMachinesService) {\r\n        var service = {\r\n            currentPc: null,\r\n            returnPromise: null,\r\n            instructionsInIF: [],\r\n            codeArrayInput: [],\r\n\r\n            parse: parse,\r\n            pipeThrough: pipeThrough\r\n        };\r\n\r\n        return service;\r\n        \r\n        /**\r\n         * Parses the instruction array, gets the required number of instructions \r\n         * (if nothing is passed, then it is presumed that the number of instructions is 1)\r\n         * from the instruction array.\r\n         * \r\n         * Returns a promise, which will be resolved when 'pipeThrough' is called.\r\n         */\r\n        function parse(currentPc, instructionArray, howManyInstructionsToPipe) {\r\n            IFModel.currentPc = currentPc || 0;\r\n            howManyInstructionsToPipe = howManyInstructionsToPipe || 1;\r\n            IFModel.returnPromise = $q.defer();\r\n            var sliceFrom = IFModel.currentPc;\r\n            var sliceTo = IFModel.currentPc + howManyInstructionsToPipe;\r\n            service.codeArrayInput = angular.copy(instructionArray);\r\n\r\n            var slicedInstructions = instructionArray.slice(sliceFrom, sliceTo);\r\n\r\n            checkForBranchInstructions(slicedInstructions);\r\n            IFModel.instructionsInIF = slicedInstructions;\r\n            return IFModel.returnPromise.promise;\r\n        }\r\n\r\n        function checkForBranchInstructions(instructionArray) {\r\n            var i = 0;\r\n\r\n            while (i < instructionArray.length) {\r\n                var currentLine = instructionArray[i];\r\n                var decodedInstruction = IDService.decodeSingleInstruction(currentLine);\r\n                var instructionPc = i + IFModel.currentPc;\r\n\r\n                var isJmpInstruction = jmpInstructionService.isJmpInstruction(decodedInstruction.operation);\r\n                var currentPrediction = predictionMachinesService.getCurrentPrediction(instructionPc) ? 1 : 0;\r\n\r\n                if (isJmpInstruction && \r\n                    currentPrediction) {\r\n\r\n                    var numOfInstructions = instructionArray.length - i - 1;\r\n                    var predictedAddress = getPredictedAddress(decodedInstruction);\r\n                    if (numOfInstructions > 0) {\r\n                    \r\n                        // We need to replace the instructions that are after the jump instruction\r\n                        // with the instructions that are predicted.\r\n                        var predictedValues = getPredictedValues(predictedAddress, numOfInstructions);\r\n\r\n                        // Append new instructions, to the array of instructions,\r\n                        // that will be passed to IDService.\r\n                        instructionArray.splice(i, \r\n                        numOfInstructions);\r\n                        instructionArray.concat(predictedValues);\r\n                    }\r\n\r\n                    /** Adding the predicted instruction\r\n                     *  to the array of predicted instructions.\r\n                     *  It will be used later, when the instruction executes\r\n                     */\r\n                    pcService.branchesPredictedTaken.push(instructionPc);\r\n\r\n                    // Setting the next PC.\r\n                    pcService.overridePc = predictedAddress + numOfInstructions;\r\n\r\n                }\r\n                i++;\r\n            }\r\n\r\n            return instructionArray;\r\n        }\r\n\r\n        function getPredictedValues(labelAddress, num) {\r\n            var sliceToAddress = labelAddress + num;\r\n            \r\n            return service.codeArrayInput.slice(labelAddress, sliceToAddress);        \r\n        }\r\n\r\n        function getPredictedAddress(instructionObj) {\r\n            var label = instructionObj.firstOperator;\r\n            return labelService.getAddress(label);\r\n        }\r\n        \r\n        /**\r\n         * Resolves the promise with the required number of instructions\r\n         */        \r\n        function pipeThrough() {\r\n            if (IFModel.returnPromise) {\r\n                var objectToPipe = {\r\n                    currentPc: IFModel.currentPc,\r\n                    instructionSet: IFModel.instructionsInIF  \r\n                };\r\n                IFModel.returnPromise.resolve(objectToPipe);\r\n                return IFModel.returnPromise.promise;\r\n            }\r\n            return $q.resolve();\r\n        }\r\n    }\r\n})();\r\n","(function() {\r\n    'use strict';\r\n\r\n    angular.module('core')\r\n        .factory('WBModel', WBModel);\r\n\r\n    WBModel.$inject = [];\r\n    function WBModel() {\r\n        var service = {\r\n            currentPc: null,\r\n            returnPromise: null,\r\n            instructionsInWB: [],\r\n            writeBackResults: [],\r\n\r\n            flush: flush\r\n        };\r\n\r\n        return service;\r\n        \r\n        function flush() {\r\n            service.currentPc = 0;\r\n            service.instructionsInWB = [];\r\n            service.writeBackResults = [];\r\n            service.returnPromise.resolve();            \r\n        }\r\n    }\r\n})();\r\n","(function () {\r\n    'use strict';\r\n\r\n    angular.module('core')\r\n        .factory('WBService', WBService);\r\n\r\n    WBService.$inject = ['registerService',\r\n        '$q',\r\n        'WBModel'];\r\n    function WBService(registerService,\r\n        $q,\r\n        WBModel) {\r\n        var dontWriteBack = ['cmp', 'end'];\r\n\r\n        var service = {\r\n            endReached: false,\r\n\r\n            parse: parse,\r\n            pipeThrough: pipeThrough,\r\n            shouldWriteBack: shouldWriteBack\r\n        };\r\n\r\n        return service;\r\n\r\n        function parse(objectFromEx) {\r\n            WBModel.currentPc = objectFromEx.currentPc;\r\n            WBModel.instructionsInWB = objectFromEx.instructionSet;\r\n            WBModel.writeBackResults = objectFromEx.writeBackResults;\r\n            writeBack(objectFromEx.writeBackResults);\r\n            WBModel.returnPromise = $q.defer();\r\n\r\n            return WBModel.returnPromise.promise;\r\n        }\r\n\r\n        function writeBack(writeBackSet) {\r\n            writeBackSet.forEach(function (writeBackObject) {\r\n                var dst = writeBackObject.register;\r\n                var value = writeBackObject.result;\r\n                var op = writeBackObject.operation;\r\n\r\n                if (op === 'end') {\r\n                    service.endReached = true;\r\n                }\r\n\r\n                if (shouldWriteBack(op)) {\r\n                    registerService.setValueOfReg(dst, value);\r\n                }\r\n            });\r\n        }\r\n\r\n        function shouldWriteBack(operation) {\r\n\r\n            /** If the operation is not in the dontWriteBack array\r\n             *  we shouldn't preform a WB operation on the first operator.\r\n             */\r\n            return dontWriteBack.indexOf(operation) === -1;\r\n        }\r\n\r\n        function pipeThrough() {\r\n            if (WBModel.returnPromise) {\r\n                WBModel.returnPromise.resolve(WBModel.writeBackResults);\r\n                return WBModel.returnPromise.promise;\r\n            }\r\n\r\n            return $q.resolve();\r\n        }\r\n    }\r\n})();","(function() {\r\n    'use strict';\r\n\r\n    angular.module('core')\r\n            .constant('Math', window.Math);\r\n})();","(function () {\r\n    'use strict';\r\n\r\n    angular.module('core')\r\n        .factory('registerService', registerService);\r\n\r\n    registerService.$inject = ['speculativeModel'];\r\n    function registerService(speculativeModel) {\r\n        var service = {\r\n            coreRegisters: {\r\n                ax: 0,\r\n                bx: 0,\r\n                cx: 0,\r\n                dx: 0,\r\n                sp: 0,\r\n                bp: 0,\r\n                si: 0,\r\n                di: 0\r\n            },\r\n            otherRegisters: {},\r\n\r\n            getValueOfReg: getValueOfReg,\r\n            setValueOfReg: setValueOfReg\r\n        };\r\n\r\n        return service;\r\n\r\n        /**\r\n         * Get the value with the regName,\r\n         * from the registers or from the speculated buffer.\r\n         * \r\n         * If not in core registers, check the other registers.\r\n         * If not in the other registers, assume that the value will be 0,\r\n         * and update the other registers.\r\n         * \r\n         * Finally, if a value like this exists in the speculated buffer, use it.\r\n         * If it doesn't exist, use the previously fetched from register value.\r\n         */\r\n        function getValueOfReg(regName) {\r\n            var regValue = 0,\r\n                speculativeLength = speculativeModel.buffer.length,\r\n                latestSpecualtedValues = speculativeLength ? \r\n                                        speculativeModel.buffer[speculativeLength - 1].valuesToCommit : 0,\r\n                // speculatedValueToUse = latestSpecualtedValues[regName];\r\n                speculatedValueToUse = getValueFromSpeculated(regName);\r\n\r\n            if (service.coreRegisters[regName] !== undefined) {\r\n                regValue = service.coreRegisters[regName];\r\n\r\n            } else if (service.otherRegisters[regName] !== undefined) {\r\n                regValue = service.otherRegisters[regName];\r\n            } else {\r\n                service.otherRegisters[regName] = 0;\r\n            }\r\n            regValue = speculatedValueToUse || regValue;\r\n\r\n            return regValue;\r\n        }\r\n\r\n        /**\r\n         * Go from top to bottom, of the speculative buffer,\r\n         * and get the latest value (if it exists in the buffer).\r\n         */\r\n        function getValueFromSpeculated(regName) {\r\n            var valueToReturn = null;\r\n            var tempBuffer = speculativeModel.buffer;\r\n            tempBuffer.reverse();\r\n\r\n            tempBuffer.some(function(value) {\r\n                if (value.valuesToCommit[regName]) {\r\n                    valueToReturn = value.valuesToCommit[regName];\r\n                    return true;\r\n                }\r\n            });\r\n            \r\n            // Return the buffer to the original order.\r\n            tempBuffer.reverse();\r\n            return valueToReturn;\r\n        }\r\n\r\n        function setValueOfReg(regName, regValue) {\r\n\r\n            if (service.coreRegisters[regName] !== undefined) {\r\n                service.coreRegisters[regName] = regValue;\r\n            } else {\r\n                service.otherRegisters[regName] = regValue;\r\n            }\r\n\r\n            return regName;\r\n        }\r\n    }\r\n})();","(function () {\r\n    'use strict';\r\n\r\n    angular.module('core')\r\n        .factory('speculativeModel', speculativeModel);\r\n\r\n    /**\r\n     * The speculatively executed values are in the object\r\n     * Example buffer array object: {\r\n     *      pc: 1234,\r\n     *      valuesToCommit: {\r\n     *          ax: 5,\r\n     *          bx: 6,\r\n     *          cx: 7,\r\n     *          ...\r\n     *          calculated: false\r\n     *      },\r\n     *      delay: 38,\r\n     *      predictedValue: 0,\r\n     *      calculatedValue: 1\r\n     * }\r\n     * \r\n     * If our prediction is correct, these values will replace the values in the memory.\r\n     * Otherwise these values will get discarded.\r\n     */\r\n    speculativeModel.$inject = [];\r\n    function speculativeModel() {\r\n        var service = {\r\n            addingToSpeculative: false,\r\n            buffer: [],\r\n            size: 6,\r\n\r\n            initialize: initialize,\r\n            setMaxNumberOfBits: setMaxNumberOfBits,\r\n            shiftWithValue: shiftWithValue,\r\n            formPredictedArray: formPredictedArray\r\n        };\r\n        return service;\r\n\r\n        function initialize(newSize) {\r\n            var size = newSize || service.size;\r\n\r\n            setMaxNumberOfBits(size);\r\n        }\r\n\r\n        function setMaxNumberOfBits(numberOfBits) {\r\n            service.buffer = [];\r\n\r\n            for (var i = 0; i < numberOfBits; i++) {\r\n                service.buffer[i] = {\r\n                    branchInfo: {\r\n                        predictedValue: 0\r\n                        },\r\n                    valuesToCommit: {},\r\n                    predictionOverrides: {}\r\n                };\r\n            }\r\n        }\r\n\r\n        function shiftWithValue(newValue) {\r\n            service.buffer.shift();\r\n            service.buffer.push(newValue);\r\n        }\r\n\r\n        /**\r\n         * Helper function for forming an array which contains only predicted values,\r\n         * so we can concat it to the corelation register.\r\n         */\r\n        function formPredictedArray(bufferArray) {\r\n            var tempBuffer = [];\r\n\r\n            bufferArray.forEach(function (bufferItem) {\r\n                tempBuffer.push(bufferItem.branchInfo.predictedValue);\r\n            });\r\n\r\n            return tempBuffer;\r\n        }\r\n    }\r\n})();\r\n","(function () {\r\n    'use strict';\r\n\r\n    angular.module('core')\r\n        .factory('speculativeService', speculativeService);\r\n\r\n    /**\r\n     * The speculatively executed values are in the object\r\n     * Example buffer array object: {\r\n     *      pc: 1234,\r\n     *      valuesToCommit: {\r\n     *          ax: 5,\r\n     *          bx: 6,\r\n     *          cx: 7,\r\n     *          ...\r\n     *          calculated: true\r\n     *      },\r\n     *      predictedValue: 0\r\n     * }\r\n     * \r\n     * If our prediction is correct, these values will replace the values in the memory.\r\n     * Otherwise these values will get discarded.\r\n     */\r\n    speculativeService.$inject = ['$timeout',\r\n        'registerService',\r\n        'speculativeModel',\r\n        'corelationRegisterService',\r\n        'localHistoryTableService',\r\n        'predictionMachinesService',\r\n        'pcService',\r\n        'common',\r\n        '$interval'];\r\n    function speculativeService($timeout,\r\n        registerService,\r\n        speculativeModel,\r\n        corelationRegisterService,\r\n        localHistoryTableService,\r\n        predictionMachinesService,\r\n        pcService,\r\n        common,\r\n        $interval) {\r\n\r\n        var service = {\r\n            clear: clear,\r\n            modelIsEmpty: modelIsEmpty,\r\n            addTo: addTo,\r\n            comfitValues: commitValues,\r\n            createNewBranchBuffer: createNewBranchBuffer,\r\n            mergeAndCommitValues: mergeAndCommitValues,\r\n            setBufferToCalculated: setBufferToCalculated,\r\n            misprediction: misprediction,\r\n            getNextUncalculated: getNextUncalculated,\r\n            getLatestSpeculatedValues: getLatestSpeculatedValues\r\n        };\r\n        return service;\r\n\r\n        function modelIsEmpty() {\r\n            return speculativeModel.buffer.length === 0;\r\n        }\r\n\r\n        function clear() {\r\n            speculativeModel.buffer = [];\r\n        }\r\n\r\n        /**\r\n         * Create a new branch buffer, add it's pc, and an empty object,\r\n         * which will contain our may-be-commited set of values.\r\n         */\r\n        function createNewBranchBuffer(branchInfo, predictionOverrides) {\r\n            var newBranchBuffer = {\r\n                branchInfo: branchInfo,\r\n                valuesToCommit: {},\r\n                predictionOverrides: predictionOverrides\r\n            };\r\n\r\n            shiftWithValue(newBranchBuffer);\r\n            return speculativeModel.buffer[speculativeModel.buffer.length - 1];\r\n        }\r\n\r\n        /**\r\n         * Adds to the may-be-commited set of values,\r\n         * of the last branch buffer.\r\n         */\r\n        function addTo(dst, value) {\r\n            var lastBranchBuffer = speculativeModel.buffer.length - 1;\r\n\r\n            speculativeModel.buffer[lastBranchBuffer].valuesToCommit[dst] = value;\r\n        }\r\n\r\n        /**\r\n         * If the branch has been calculated, merge it forward.\r\n         */\r\n        function mergeAndCommitValues(valueBuffer) {\r\n            var newBuffer = speculativeModel.buffer,\r\n                lastCommitedIndex = getLastCommitedIndex(newBuffer);\r\n\r\n            /**\r\n            * Remove mispredictions from the buffer\r\n            */\r\n            newBuffer = removeMispredictions(newBuffer);\r\n\r\n            /**\r\n             * Commit all the correctly calculated values,\r\n             * to the memory.\r\n             * \r\n             * Only the values from the first (as in with index = 0) predicted branch, \r\n             * to the last calculated and correctly predicted branch,\r\n             * will be commited.\r\n             */\r\n            newBuffer.some(function (branchBuffer, branchIndex) {\r\n                if (branchBuffer.branchInfo.calculated) {\r\n                    var calculatedValue = branchBuffer.branchInfo.calculatedValue;\r\n                    lastCommitedIndex = branchIndex;\r\n\r\n                    if (corelationRegisterService.useCor) {\r\n                        corelationRegisterService.value.push(calculatedValue);\r\n                    }\r\n\r\n                    if (branchBuffer.branchInfo.shouldCommit) {\r\n                        commitValues(branchBuffer);\r\n                    }\r\n                }\r\n                return !branchBuffer.branchInfo.calculated;\r\n            });\r\n\r\n            /**\r\n             * Remove all the calculated values from the buffer,\r\n             * because they are not necessarry anymore.\r\n             */\r\n            var spliceTo = getNextUncalculated(newBuffer);\r\n            newBuffer.splice(0, spliceTo);\r\n        }\r\n\r\n        function shiftWithValue(newValue) {\r\n            var corelationSize = corelationRegisterService.value.length,\r\n                corelationMaxSize = corelationRegisterService.size,\r\n                speculativeSize = speculativeModel.buffer.length,\r\n                speculativeMaxSize = speculativeModel.size;\r\n\r\n            if (speculativeSize < speculativeMaxSize) {\r\n                speculativeModel.buffer.push(newValue);\r\n                if (corelationRegisterService.useCor) {\r\n                    corelationRegisterService.value.shift();\r\n                }\r\n            } else {\r\n                $interval.cancel(common.pipelineInterval);\r\n                window.alert('Too much! Stopping execution...');\r\n                $timeout(function () {\r\n                    common.flushPipeline();\r\n                    clear();\r\n                    corelationRegisterService.clear();\r\n                    localHistoryTableService.clear();\r\n                    predictionMachinesService.clear();\r\n                    common.pipelineActive = false;\r\n                    common.pipelineStarted = false;\r\n                    // console.log('That\\'s too much man!');\r\n                }, 10);\r\n            }\r\n        }\r\n\r\n        function getLastCommitedIndex(newBuffer) {\r\n            var lastCommitedIndex = -1;\r\n\r\n            newBuffer.some(function (branchBuffer, branchIndex) {\r\n\r\n                if (branchBuffer.branchInfo.calculated &&\r\n                    branchBuffer.branchInfo.shouldCommit) {\r\n\r\n                    lastCommitedIndex = branchIndex;\r\n                }\r\n                return !branchBuffer.branchInfo.shouldCommit;\r\n            });\r\n\r\n            return lastCommitedIndex;\r\n        }\r\n\r\n        /**\r\n         * Helper method for commiting the misprediction.\r\n         * \r\n         * Gets the first uncommited element in the buffer,\r\n         * (if it exists)\r\n         * and if it is mispredicted, commits it.\r\n         * \r\n         * We only do this for the first element, \r\n         * because all subsequent assumptions are false, and should not be commited.\r\n         */\r\n        function commitMisprediction(newBuffer, lastCommitedIndex) {\r\n            var firstUncommitedIndex = lastCommitedIndex + 1,\r\n                firstUncommited = newBuffer[lastCommitedIndex + 1];\r\n\r\n            /**\r\n             * Safeguard if the last commited one was at the end of the array\r\n             */\r\n            if (firstUncommited &&\r\n                firstUncommited.branchInfo.mispredicted) {\r\n\r\n                restorePredictions(firstUncommited, newBuffer);\r\n                var calculatedValue = firstUncommited.branchInfo.calculatedValue;\r\n\r\n                pcService.overridePc = firstUncommited.branchInfo.mispredictionPc;\r\n\r\n                // Update the predictions with the correct value.\r\n                predictionMachinesService.updatePredictions(calculatedValue);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Helper function for restoring the predictions, \r\n         * at which point the misprediction was made.\r\n         */\r\n        function restorePredictions(firstUncommited, newBuffer) {\r\n            newBuffer.reverse().some(function (mispredicted) {\r\n\r\n                if (mispredicted === firstUncommited) {\r\n                    return true;\r\n                }\r\n\r\n                /**\r\n                 * Restoring all the previous mispredictions.\r\n                 */\r\n                var localHistoryIndex = mispredicted.predictionOverrides.localHistoryIndex,\r\n                    localHistoryArray = mispredicted.predictionOverrides.localHistoryArray,\r\n                    predictionMachineIndex = mispredicted.predictionOverrides.predictionMachineIndex,\r\n                    predictionMachineValue = mispredicted.predictionOverrides.predictionMachineValue;\r\n\r\n                localHistoryTableService.setLocalHistoryArray(localHistoryIndex, localHistoryArray);\r\n                predictionMachinesService.setPrediction(predictionMachineIndex, predictionMachineValue);\r\n            });\r\n\r\n            // Restore the buffer to the original order\r\n            newBuffer.reverse();\r\n\r\n            // Finally, restore the last misprediction.\r\n            var localHistoryIndex = firstUncommited.predictionOverrides.localHistoryIndex,\r\n                localHistoryArray = firstUncommited.predictionOverrides.localHistoryArray,\r\n                predictionMachineIndex = firstUncommited.predictionOverrides.predictionMachineIndex,\r\n                predictionMachineValue = firstUncommited.predictionOverrides.predictionMachineValue;\r\n\r\n            localHistoryTableService.setLocalHistoryArray(localHistoryIndex, localHistoryArray);\r\n            predictionMachinesService.setPrediction(predictionMachineIndex, predictionMachineValue);\r\n\r\n        }\r\n\r\n        /**\r\n         * Helper function for removing all mispredictions.\r\n         * It removes the mispredicted element, \r\n         * and all the predictions that came after it.\r\n         * \r\n         * (All consequent predictions are mispredictions,\r\n         * because they are bassed on the assumption that all previous predictions,\r\n         * are coorect.)\r\n         */\r\n        function removeMispredictions(newBuffer) {\r\n            var mispredictedIndex = null,\r\n                updateWith = null,\r\n                restoreBranchBuffer = null,\r\n                pcToUse = 0;\r\n            newBuffer.some(function (branchBuffer, index, branchArray) {\r\n\r\n                if (branchBuffer.branchInfo.mispredicted) {\r\n\r\n                    // Set to null, so we don't trigget it again\r\n                    branchBuffer.branchInfo.mispredicted = null;\r\n                    updateWith = branchBuffer.branchInfo.calculatedValue;\r\n                    mispredictedIndex = index;\r\n                    pcToUse = branchBuffer.branchInfo.pc;\r\n                    pcService.overridePc = branchBuffer.branchInfo.mispredictionPc;\r\n\r\n                    restorePredictions(branchBuffer, newBuffer);\r\n                    return true;\r\n                }\r\n            });\r\n\r\n            if (mispredictedIndex !== null) {\r\n                var numberOfItemsToRemove = newBuffer.length - (mispredictedIndex + 1);\r\n\r\n                if (corelationRegisterService.useCor) {\r\n                    for (var i = 0; i < numberOfItemsToRemove; i++) {\r\n                        corelationRegisterService.value.splice(0, 0, 0);\r\n                    }\r\n                }\r\n                newBuffer.splice(mispredictedIndex + 1, numberOfItemsToRemove);\r\n\r\n                predictionMachinesService.updatePredictionsExceptCorelation(updateWith, pcToUse);\r\n            }\r\n\r\n            return newBuffer;\r\n        }\r\n\r\n        /**\r\n         * Helper function for setting the calculated flag.\r\n         */\r\n        function setBufferToCalculated(branchPc) {\r\n\r\n            speculativeModel.buffer.some(function (value, index, arr) {\r\n                if (value.pc === branchPc) {\r\n                    arr[index].calculated = true;\r\n                    return true;\r\n                }\r\n            });\r\n\r\n            return speculativeModel.buffer;\r\n        }\r\n\r\n        /**\r\n         * If we have a misprediction,\r\n         * everything predicted from this point onward should be flushed.\r\n         */\r\n        function misprediction(branchPc) {\r\n            var removeFromHere = null;\r\n\r\n            speculativeModel.buffer.some(function (value, index, arr) {\r\n\r\n                if (value.pc === branchPc) {\r\n                    var remaning = arr.length - index;\r\n                    arr.splice(index, remaning);\r\n                    return true;\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Commit values of the first item in the array to the registers\r\n         * Be careful to only do it if the first value has been calculated.\r\n         */\r\n        function commitValues(branchBuffer) {\r\n            var valuesToCommit = branchBuffer.valuesToCommit;\r\n\r\n            angular.forEach(valuesToCommit, function (value, dst) {\r\n                registerService.setValueOfReg(dst, value);\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Helper function for getting the next uncalculated.\r\n         */\r\n        function getNextUncalculated(buffer) {\r\n            var indexToReturn = buffer.length;\r\n\r\n            buffer.some(function (value, index) {\r\n                if (!value.branchInfo.calculated) {\r\n                    indexToReturn = index;\r\n                    return true;\r\n                }\r\n            });\r\n\r\n            return indexToReturn;\r\n        }\r\n\r\n        /**\r\n         * Helper function for getting the latest speculative buffer,\r\n         * and fetching the values to commit from it.\r\n         */\r\n        function getLatestSpeculatedValues() {\r\n            return speculativeModel.buffer[speculativeModel.buffer.length - 1].valuesToCommit;\r\n        }\r\n    }\r\n\r\n\r\n})();","(function () {\r\n\t'use strict';\r\n\r\n\tangular.module('app')\r\n\t\t.controller('CorelationRegisterController', CorelationRegisterController);\r\n\r\n\tCorelationRegisterController.$inject = ['corelationRegisterService',\r\n\t\t'localHistoryTableService',\r\n\t\t'predictionMachinesService',\r\n\t\t'speculativeModel'];\r\n\tfunction CorelationRegisterController(corelationRegisterService,\r\n\t\tlocalHistoryTableService,\r\n\t\tpredictionMachinesService,\r\n\t\tspeculativeModel) {\r\n\r\n\t\tvar vm = this;\r\n\r\n\t\tvm.corelationRegister = corelationRegisterService;\r\n\t\tvm.locationHistoryTable = localHistoryTableService;\r\n\t\tvm.predictionMachines = predictionMachinesService;\r\n\t\tvm.speculativeModel = speculativeModel;\r\n\r\n\t\tvm.updateValues = updateValues;\r\n\t\tvm.getStyleForPrediction = getStyleForPrediction;\r\n\r\n\t\tactivate();\r\n\r\n\t\tfunction activate() {\r\n\t\t\t// vm.corelationRegister.setMaxNumberOfBits(service.size);\r\n\t\t\tvm.corelationRegister.initializeCR();\r\n\t\t\t// speculativeModel.initialize();\r\n\t\t}\r\n\r\n\t\tfunction updateValues() {\r\n\t\t\tvar corelationTotalSize = corelationRegisterService.size,\r\n\t\t\t\tlhtSize = localHistoryTableService.size;\r\n\r\n\t\t\tvm.corelationRegister.setMaxNumberOfBits(vm.corelationRegister.size);\r\n\t\t\tvm.locationHistoryTable.initializeLHT();\r\n\t\t\tvm.predictionMachines.setMachineSize(corelationTotalSize, lhtSize);\r\n\t\t}\r\n\r\n\t\tfunction getStyleForPrediction(predictionInfo) {\r\n\t\t\tvar styleMap = {\r\n\t\t\t\t'true': { color: 'green' },\r\n\t\t\t\t'undefined': { color: 'red' }\r\n\t\t\t};\r\n\r\n\t\t\treturn styleMap[predictionInfo.calculated];\r\n\t\t}\r\n\t}\r\n})();\r\n","(function() {\r\n\t'use strict';\r\n\r\n\tangular.module('app')\r\n\t\t\t.directive('corelationRegister', corelationRegister);\r\n\r\n\tcorelationRegister.$inject = [];\r\n\tfunction corelationRegister() {\r\n\t\tvar directive = {\r\n\t\t\trestrict: 'E',\r\n\t\t\tcontroller: 'CorelationRegisterController',\r\n\t\t\tcontrollerAs: 'corReg',\r\n\t\t\ttemplateUrl: 'app/corelationRegister/corelation-register.html'\r\n\t\t};\r\n\r\n\t\treturn directive;\r\n\t}\r\n})();\r\n","\r\n(function() {\r\n\t'use strict';\r\n\r\n\tangular.module('app')\r\n\t\t.factory('corelationRegisterService', corelationRegisterService);\r\n\r\n  \tcorelationRegisterService.$inject = [];\r\n  \tfunction corelationRegisterService() {\r\n    \tvar service = {\r\n    \t\tvalue: [],\r\n\t\t\tsize: 12,\r\n\t\t\tuseCor: true,\r\n\r\n    \t\tsetMaxNumberOfBits: setMaxNumberOfBits,\r\n    \t\tshiftWithValue: shiftWithValue,\r\n\t\t\tgetRegisterValue: getRegisterValue,\r\n\t\t\tinitializeCR: initializeCR,\r\n\t\t\tgetCopy: getCopy,\r\n\t\t\tclear: clear\r\n    \t};\r\n\r\n    \treturn service;\r\n\r\n\t\tfunction initializeCR(newCRSize) {\r\n\t\t\tvar sizeOfCR = newCRSize || service.size;\r\n\r\n\t\t\tsetMaxNumberOfBits(sizeOfCR);\r\n\t\t}\r\n\r\n    \tfunction setMaxNumberOfBits(numberOfBits) {\r\n\t\t\tservice.value = [];\r\n\r\n            for (var i = 0; i < numberOfBits; i++) {\r\n                service.value[i] = 0;\r\n            }\r\n    \t}\r\n\r\n        function shiftWithValue(newValue) {\r\n            service.value.shift();\r\n            service.value.push(newValue);\r\n        }\r\n\r\n\t\tfunction getRegisterValue() {\r\n\t\t\tvar stringBinaryNumber = service.value.join('');\r\n\t\t\treturn parseInt(stringBinaryNumber, 2);\r\n\t\t}\r\n\r\n\t\tfunction getCopy() {\r\n\t\t\treturn angular.copy(service.value);\r\n\t\t}\r\n\r\n\t\tfunction clear() {\r\n\t\t\tservice.value = [];\r\n\t\t\tinitializeCR();\r\n\t\t}\r\n  \t}\r\n})();\r\n","(function () {\r\n  angular.module('app')\r\n    .controller('localHistoryTableController', localHistoryTableController);\r\n\r\n  localHistoryTableController.$inject = ['localHistoryTableService',\r\n    'pcService',\r\n    'corelationRegisterService',\r\n    'speculativeModel',\r\n    'predictionMachinesService'];\r\n  function localHistoryTableController(localHistoryTableService,\r\n    pcService,\r\n    corelationRegisterService,\r\n    speculativeModel,\r\n    predictionMachinesService) {\r\n    var vm = this;\r\n\r\n    vm.localHistoryTable = localHistoryTableService;\r\n    vm.predictionMachines = predictionMachinesService;\r\n    vm.updateValues = updateValues;\r\n    vm.checkIfChanged = checkIfChanged;\r\n    vm.corelationRegister = corelationRegisterService;\r\n\r\n    activate();\r\n\r\n    function activate() {\r\n      vm.localHistoryTable.initializeLHT();\r\n    }\r\n\r\n    function checkIfChanged(index) {\r\n      return localHistoryTableService.changed.indexOf(index) !== -1;\r\n    }\r\n\r\n    function updateValues(newLhtSize) {\r\n      var corelationTotalSize = corelationRegisterService.size,\r\n        lhtSize = localHistoryTableService.size;\r\n\r\n      localHistoryTableService.setSizeOfRegisters();\r\n      vm.predictionMachines.setMachineSize(corelationTotalSize, lhtSize);\r\n    }\r\n  }\r\n})();\r\n","(function() {\r\n\t'use strict';\r\n\r\n\tangular.module('app')\r\n\t\t\t.directive('localHistoryTable', localHistoryTable);\r\n\r\n\tlocalHistoryTable.$inject = [];\r\n\tfunction localHistoryTable() {\r\n\t\tvar directive = {\r\n\t\t\trestrict: 'E',\r\n\t\t\tcontroller: 'localHistoryTableController',\r\n\t\t\tcontrollerAs: 'lht',\r\n\t\t\ttemplateUrl: 'app/localHistoryTable/local-history-table.html'\r\n\t\t};\r\n\r\n\t\treturn directive;\r\n\t}\r\n})();\r\n","(function () {\r\n\t'use strict';\r\n\r\n\tangular.module('app')\r\n\t\t.factory('localHistoryTableService', localHistoryTableService);\r\n\r\n\tlocalHistoryTableService.$inject = ['corelationRegisterService',\r\n\t\t'speculativeModel',\r\n\t\t'Math'];\r\n\tfunction localHistoryTableService(corelationRegisterService,\r\n\t\tspeculativeModel,\r\n\t\tMath) {\r\n\t\tvar service = {\r\n\t\t\tvalue: [],\r\n\t\t\tsize: 3,\r\n\t\t\tchanged: [],\r\n\t\t\tnumOfPcBits: 3,\r\n\t\t\tuseLht: true,\r\n\t\t\tlocalHistoryTableActive: false,\r\n\r\n\t\t\tsetMaxNumberOfBits: setMaxNumberOfBits,\r\n\t\t\tsetSizeOfRegisters: setSizeOfRegisters,\r\n\t\t\tshiftWithValue: shiftWithValue,\r\n\t\t\tgetLocalHistoryValue: getLocalHistoryValue,\r\n\t\t\tinitializeLHT: initializeLHT,\r\n\t\t\tgetCopyOfLocalHistoryArrayFor: getCopyOfLocalHistoryArrayFor,\r\n\t\t\tsetLocalHistoryArray: setLocalHistoryArray,\r\n\t\t\tclear: clear\r\n\t\t};\r\n\r\n\t\tactivate();\r\n\r\n\t\treturn service;\r\n\r\n\t\tfunction activate() { }\r\n\r\n\t\tfunction initializeLHT(sizeOfRegister) {\r\n\t\t\tvar registerSize = sizeOfRegister || service.size,\r\n\t\t\t\tnumberOfRegisters = Math.pow(corelationRegisterService.size + speculativeModel.size, 2);\r\n\t\t\tservice.value = [];\r\n\r\n\t\t\tsetNumberOfRegisters(numberOfRegisters);\r\n\t\t\tsetSizeOfRegisters(registerSize);\r\n\t\t}\r\n\r\n\t\tfunction setNumberOfRegisters(numberOfLHTRegisters) {\r\n\t\t\tvar i = 0;\r\n\r\n\t\t\twhile (i < numberOfLHTRegisters) {\r\n\t\t\t\tservice.value[i++] = [];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction setMaxNumberOfBits(numberOfBits) {\r\n\t\t\tvar numOfRegisters = Math.pow(2, numberOfBits);\r\n\r\n\t\t\tsetNumberOfRegisters(numOfRegisters);\r\n\r\n\t\t\tservice.value = service.value.map(function (value) {\r\n\t\t\t\tfor (var i = 0; i < numberOfBits; i++) {\r\n\t\t\t\t\tvalue[i] = 0;\r\n\t\t\t\t}\r\n\t\t\t\treturn value;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfunction setSizeOfRegisters(newSize) {\r\n\r\n\t\t\tservice.value = service.value.map(function (value) {\r\n\t\t\t\tvalue = [];\r\n\r\n\t\t\t\tfor (var i = 0; i < newSize; i++) {\r\n\t\t\t\t\tvalue[i] = 0;\r\n\t\t\t\t}\r\n\t\t\t\treturn value;\r\n\t\t\t});\r\n\t\t}\r\n\r\n        function shiftWithValue(index, newValue) {\r\n\t\t\tservice.localHistoryTableActive = true;\r\n\t\t\t\r\n\t\t\tif(service.changed.indexOf(index) === -1) {\r\n\t\t\t\tservice.changed.push(index);\r\n\t\t\t}\r\n\r\n            service.value[index].shift();\r\n            service.value[index].push(newValue);\r\n        }\r\n\r\n\t\tfunction getCopyOfLocalHistoryArrayFor(index) {\r\n\t\t\treturn angular.copy(service.value[index]);\r\n\t\t}\r\n\r\n\t\tfunction setLocalHistoryArray(index, arrayToSet) {\r\n\t\t\treturn angular.copy(arrayToSet, service.value[index]);\r\n\t\t}\r\n\r\n\t\tfunction getLocalHistoryValue(index) {\r\n\t\t\tvar lhStringValue = service.value[index].join('');\r\n\t\t\tvar lhValue = parseInt(lhStringValue, 2);\r\n\t\t\treturn lhValue;\r\n\t\t}\r\n\r\n\t\tfunction clear() {\r\n\t\t\tservice.value = [];\r\n\t\t\tservice.changed = [];\r\n\t\t\tinitializeLHT();\r\n\t\t}\r\n\t}\r\n})();\r\n","(function () {\r\n  'use strict';\r\n\r\n  angular.module('app')\r\n    .controller('PredictionMachinesController', PredictionMachinesController);\r\n\r\n  PredictionMachinesController.$inject = ['predictionMachinesService',\r\n    'corelationRegisterService',\r\n    'localHistoryTableService'];\r\n  function PredictionMachinesController(predictionMachinesService,\r\n    corelationRegisterService,\r\n    localHistoryTableService) {\r\n    var vm = this;\r\n\r\n    vm.numberOfMachines = predictionMachinesService.numOfMachines;\r\n    vm.predictionMachines = predictionMachinesService;\r\n    vm.checkIfChanged = checkIfChanged;\r\n\r\n    activate();\r\n\r\n    function activate() {\r\n      vm.predictionMachines.setMachineSize();\r\n    }\r\n\r\n    function checkIfChanged(index) {\r\n      return predictionMachinesService.changed.indexOf(index) !== -1;\r\n    }\r\n  }\r\n})();\r\n","(function() {\r\n  angular.module('app')\r\n    .directive('predictionMachines', predictionMachines);\r\n\r\n  predictionMachines.$inject = [];\r\n  function predictionMachines() {\r\n    var directive = {\r\n      restrict : 'E',\r\n      controller: 'PredictionMachinesController',\r\n      controllerAs: 'pm',\r\n      templateUrl: 'app/predictionMachines/prediction-machines.html'\r\n    };\r\n\r\n    return directive;\r\n  }\r\n})();\r\n","(function () {\r\n    'use strict';\r\n\r\n    angular.module('app')\r\n        .factory('predictionMachinesService', predictionMachinesService);\r\n\r\n    predictionMachinesService.$inject = ['corelationRegisterService',\r\n        'pcService',\r\n        'localHistoryTableService',\r\n        'speculativeModel'];\r\n    function predictionMachinesService(corelationRegisterService,\r\n        pcService,\r\n        localHistoryTableService,\r\n        speculativeModel) {\r\n        var service = {\r\n            numOfMachines: null,\r\n            sizeOfMachines: 2,\r\n            value: [],\r\n            changed: [],\r\n            predictionTableActive: false,\r\n\r\n            setMachineSize: setMachineSize,\r\n            setPrediction: setPrediction,\r\n            getCurrentPrediction: getCurrentPrediction,\r\n            updatePredictions: updatePredictions,\r\n            updatePredictionsExceptCorelation: updatePredictionsExceptCorelation,\r\n            getCopyOfMachine: getCopyOfMachine,\r\n            getValueOfMachine: getValueOfMachine,\r\n            clear: clear\r\n        };\r\n\r\n        return service;\r\n\r\n        function setMachineSize(size1, size2) {\r\n            size1 = size1 || corelationRegisterService.size;\r\n            size2 = size2 || localHistoryTableService.size;\r\n\r\n            service.numOfMachines = Math.pow(2, size1 + size2);\r\n            service.value = [];\r\n\r\n            var i = 0;\r\n            while (i < service.numOfMachines) {\r\n                service.value[i++] = [1, 0];\r\n            }\r\n        }\r\n\r\n        function updateMachine(machineIndex, value) {\r\n            var machineValue = parseInt(service.value[machineIndex].join(''), 2),\r\n                maxValue = Math.pow(2, 2) - 1;\r\n\r\n            if (service.changed.indexOf(machineIndex) === -1) {\r\n                service.changed.push(machineIndex);\r\n            }\r\n\r\n            if (value === 0 &&\r\n                machineValue > 0) {\r\n                machineValue -= 1;\r\n            } else if (value === 1 &&\r\n                machineValue < maxValue) {\r\n                machineValue += 1;\r\n            }\r\n\r\n            var binaryValue = machineValue.toString(2);\r\n            service.value[machineIndex] = padWithZeroes(binaryValue, service.sizeOfMachines).split('');\r\n\r\n            return service.value;\r\n        }\r\n\r\n        function getCurrentPrediction(pcToUse) {\r\n            var useCor = corelationRegisterService.useCor,\r\n                useLht = localHistoryTableService.useLht,\r\n                corelationRegister,\r\n                predictedArray,\r\n\r\n                localHistoryIndex,\r\n                predictionMachineIndex,\r\n                predictionValString,\r\n                predictionValue;\r\n\r\n            if (useCor && !useLht) {\r\n                corelationRegister = corelationRegisterService.getCopy();\r\n                predictedArray = speculativeModel.formPredictedArray(speculativeModel.buffer);\r\n\r\n                predictionMachineIndex = parseInt(corelationRegister.concat(predictedArray).join(''), 2);\r\n                predictionValString = service.value[predictionMachineIndex].join('');\r\n                predictionValue = parseInt(predictionValString, 2);\r\n\r\n                return predictionValue >= 2 ? true : false;\r\n\r\n            } else if (!useCor && useLht) {\r\n                predictionMachineIndex = pcService.getLastBitsOfPc(localHistoryTableService.numOfPcBits, pcToUse);\r\n                predictionValString = service.value[predictionMachineIndex].join('');\r\n                predictionValue = parseInt(predictionValString, 2);\r\n\r\n                return predictionValue >= 2 ? true : false;\r\n            } else {\r\n                corelationRegister = corelationRegisterService.getCopy();\r\n                predictedArray = speculativeModel.formPredictedArray(speculativeModel.buffer);\r\n\r\n                localHistoryIndex = parseInt(corelationRegister.concat(predictedArray).join(''), 2);\r\n                predictionMachineIndex = localHistoryTableService.getLocalHistoryValue(localHistoryIndex);\r\n                predictionValString = service.value[predictionMachineIndex].join('');\r\n                predictionValue = parseInt(predictionValString, 2);\r\n            }\r\n\r\n            return predictionValue >= 2 ? true : false;\r\n\r\n        }\r\n\r\n        /**\r\n         * Helper function for forming an array which contains only predicted values,\r\n         * so we can concat it to the corelation register.\r\n         */\r\n        function formPredictedArray(bufferArray) {\r\n            var tempBuffer = [];\r\n\r\n            bufferArray.forEach(function (bufferItem) {\r\n                tempBuffer.push(bufferItem.branchInfo.predictedValue);\r\n            });\r\n\r\n            return tempBuffer;\r\n        }\r\n\r\n        function padWithZeroes(value, howMany) {\r\n            var zeroes = '';\r\n            for (var i = 0; i < howMany; i++) {\r\n                zeroes += '0';\r\n            }\r\n\r\n            return (zeroes + value).slice(-howMany);\r\n        }\r\n\r\n        function setPrediction(predictionIndex, predictionValueToSet) {\r\n            service.value[predictionIndex] = predictionValueToSet;\r\n        }\r\n\r\n        function updatePredictions(value) {\r\n            var useCor = corelationRegisterService.useCor,\r\n                useLht = localHistoryTableService.useLht,\r\n                corelationRegister = corelationRegisterService.getCopy(),\r\n                predictedArray = speculativeModel.formPredictedArray(speculativeModel.buffer),\r\n\r\n                // localHistoryIndex = corelationRegisterService.getRegisterValue(),\r\n                localHistoryIndex = parseInt(corelationRegister.concat(predictedArray).join(''), 2),\r\n                predictionMachineIndex = localHistoryTableService.getLocalHistoryValue(localHistoryIndex);\r\n\r\n                service.predictionTableActive = true;\r\n\r\n            if (useCor && !useLht) {\r\n                predictionMachineIndex = localHistoryIndex;\r\n            } else if (!useCor && useLht) {\r\n                localHistoryIndex = pcService.getLastBitsOfPc(localHistoryTableService.numOfPcBits);\r\n                predictionMachineIndex = localHistoryTableService.getLocalHistoryValue(localHistoryIndex);\r\n            }\r\n            updateMachine(predictionMachineIndex, value);\r\n\r\n            if (useLht) {\r\n                localHistoryTableService.shiftWithValue(localHistoryIndex, value);\r\n            }\r\n\r\n            if (useCor) {\r\n                corelationRegisterService.shiftWithValue(value);\r\n            }\r\n        }\r\n\r\n        function updatePredictionsExceptCorelation(value, pcToUse) {\r\n            var useCor = corelationRegisterService.useCor,\r\n                useLht = localHistoryTableService.useLht,\r\n                corelationRegister = corelationRegisterService.getCopy(),\r\n                predictedArray = speculativeModel.formPredictedArray(speculativeModel.buffer),\r\n\r\n                localHistoryIndex = parseInt(corelationRegister.concat(predictedArray).join(''), 2),\r\n                predictionMachineIndex = localHistoryTableService.getLocalHistoryValue(localHistoryIndex);\r\n\r\n                service.predictionTableActive = true;                \r\n\r\n            if (useCor && !useLht) {\r\n                predictionMachineIndex = localHistoryIndex;\r\n            } else if (!useCor && useLht) {\r\n                localHistoryIndex = pcService.getLastBitsOfPc(localHistoryTableService.numOfPcBits, pcToUse);\r\n                predictionMachineIndex = localHistoryTableService.getLocalHistoryValue(localHistoryIndex);\r\n            }\r\n            updateMachine(predictionMachineIndex, value);\r\n\r\n            if (useLht) {\r\n                localHistoryTableService.shiftWithValue(localHistoryIndex, value);\r\n            }\r\n\r\n            updateMachine(predictionMachineIndex, value);\r\n            // localHistoryTableService.shiftWithValue(localHistoryIndex, value);\r\n        }\r\n\r\n        function getCopyOfMachine(machineIndex) {\r\n            return angular.copy(service.value[machineIndex]);\r\n        }\r\n\r\n        function getValueOfMachine(machineIndex) {\r\n            var stringBinaryNumber = service.value.join('');\r\n            return parseInt(stringBinaryNumber, 2);\r\n        }\r\n\r\n        function clear() {\r\n            service.value = [];\r\n            service.changed = [];\r\n            setMachineSize();\r\n        }\r\n    }\r\n})();\r\n","(function(/* BrowserSync-Brunch */) {\n  var url = \"//\" + location.hostname + \":3000/browser-sync/browser-sync-client.2.1.6.js\";\n  var bs = document.createElement(\"script\");\n  bs.type = \"text/javascript\"; bs.async = true; bs.src = url;\n  var s = document.getElementsByTagName(\"script\")[0];\n  s.parentNode.insertBefore(bs, s);\n})();"]}