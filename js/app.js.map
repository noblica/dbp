{"version":3,"sources":["app/TestModule/test.module.js","app/app.js","app/core/core.module.js","app/core/pipeline/pipeline.module.js","app/TestModule/test.controller.js","app/app.controller.js","app/codeInput/ALU.service.js","app/codeInput/codeInput.controller.js","app/codeInput/codeInput.directive.js","app/core/common.service.js","app/core/jmpInstruction.service.js","app/core/label.service.js","app/core/pc.service.js","app/core/pipeline/EX.model.js","app/core/pipeline/EX.service.js","app/core/pipeline/ID.model.js","app/core/pipeline/ID.service.js","app/core/pipeline/IF.model.js","app/core/pipeline/IF.service.js","app/core/pipeline/WB.model.js","app/core/pipeline/WB.service.js","app/core/pipeline/core.constants.js","app/core/register.service.js","app/core/speculative/speculative.model.js","app/core/speculative/speculative.service.js","app/corelationRegister/corelationRegister.controller.js","app/corelationRegister/corelationRegister.directive.js","app/corelationRegister/corelationRegister.service.js","app/localHistoryTable/localHistoryTable.controller.js","app/localHistoryTable/localHistoryTable.directive.js","app/localHistoryTable/localHistoryTable.service.js","app/predictionMachines/predictionMachines.controller.js","app/predictionMachines/predictionMachines.directive.js","app/predictionMachines/predictionMachines.service.js","node_modules/browser-sync-brunch/lib/vendor/browser-sync-injector.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrCA;AACA;AACA;AACA;AACA;AACA;ACLA;AACA;AACA;AACA;AACA;AACA;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CCnOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnEA;AACA;AACA;AACA;AACA;AACA;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3MA;AACA;AACA;AACA;AACA;AACA;AACA","file":"js/app.js","sourcesContent":["(function() {\n    'use strict';\n    \n    angular.module('test', []);\n})();","(function() {\n    'use strict';\n    \n    angular.module('app', ['ui.router',\n                            'ui.bootstrap',\n                            'ngAnimate',\n                            'core', \n                            'pipeline',\n                           'test'])\n        .config(routeConfiguration);\n    \n    routeConfiguration.$inject = ['$stateProvider', '$urlRouterProvider'];\n    function routeConfiguration($stateProvider, $urlRouterProvider) {\n        $stateProvider\n            .state('app', {\n                abstract: true,\n                controller: 'AppController',\n                controllerAs: 'app',\n                template: '<ui-view></ui-view>'\n            })\n            .state('app.home', {\n                url: '',\n                controller: 'TestController',\n                controllerAs: 'vm',\n                templateUrl: 'app/TestModule/test.html'\n            });\n        \n        $urlRouterProvider\n            .when('', goHome)\n            .when('/', goHome)\n            .otherwise('/error/404');\n        \n        goHome.$inject = ['$state'];\n        function goHome($state) {\n            $state.go('app.home');\n        }\n    }\n})();","(function() {\n    'use strict';\n\n    angular.module('core', []);\n    \n})();","(function() {\n    'use strict';\n\n    angular.module('pipeline', []);\n    \n})();","(function() {\n    'use strict';\n\n    angular.module('test')\n        .controller('TestController', TestController);\n\n    TestController.$inject = [];\n    function TestController() {\n        var vm = this;\n\n        vm.corelationRegisterCollapse = false;\n        vm.localHistoryCollapse = true;\n        vm.predictionMachinesCollapse = true;\n\n        vm.toggleLocalHistory = toggleLocalHistory;\n\n        activate();\n\n        function activate() {}\n\n        function toggleLocalHistory(historyHandler) {\n            vm.localHistoryCollapse = !vm.localHistoryCollapse;\n            console.log(vm.localHistoryCollapse);\n        }\n    }\n})();\n","(function() {\n    'use strict';\n    \n    angular.module('app')\n        .controller('AppController', AppController);\n    \n    AppController.$inject = [];\n    function AppController() {\n        var vm = this;\n        \n        activate();\n        \n        function activate() {\n            console.log('Layout controller loaded!');    \n        }\n    }\n})();","/**\n * A service that decodes the operation,\n * and actually executes it, and also sets the corresponding flags.\n */\n\n(function() {\n  'use strict';\n\n  /*jshint bitwise: false*/\n  /*jshint maxcomplexity: false*/\n  angular.module('app')\n    .factory('aluService', aluService);\n\n  aluService.$inject = ['registerService'];\n  function aluService(registerService) {\n    var service = {\n        flags: {\n            ZF: false,\n            CF: false,\n            OF: false,\n            SF: false\n        },\n        a: 0,\n        aRegName: '',\n        b: 0,\n        bRegName: '',\n        cmpResult: 0,\n        maxValue: Math.pow(2, 16) - 1,\n       \n        maxValueSigned: Math.pow(2, 15) - 1,\n        bitSize: 15,\n\n        compareAndSetFlags: compareAndSetFlags\n\n        // cmpResult values:\n        // 0 - Previous comparison result is a = b\n        // <0 - Previous comparison is a < b\n        // >0 - Previous comparison is a > b\n    };\n\n    return service;\n\n    /**\n     * Helper function for setiting the maximum value allowed.\n     * The value should be set in bits.\n     */\n    function setMaxValue(newBitValue) {\n        service.maxValue = Math.pow(2, newBitValue) - 1;\n        service.maxValueSigned = Math.pow(2, newBitValue - 1) - 1;\n        return service.maxValue;\n    }\n    \n    function setRegNamesAndValues(value1, value2) {\n        \n        // service.a = registerService.getValueOfReg(value1) || service.a;\n        service.a = registerService.getValueOfReg(value1);\n        service.b = Number(value2) !== undefined ? \n                    Number(value2) :\n                    service.b;\n        \n        /**\n         * If the second operator is not a number,\n         * it can only be a name of a register.\n         * So we fetch the value from that register, and use it from here on out.\n         */\n        if (isNaN(value2)) {\n            service.bRegName = value2;\n            service.b = registerService.getValueOfReg(value2);\n        }\n    }\n    \n    /**\n     * Decodes the operation using switch-case,\n     * assigns the parsed values to the service,\n     * executes the operation, and sets the flags.\n     */\n    function compareAndSetFlags(newA, newB, operation) {\n        \n        /**\n         * Get the values.\n         * If they aren't being passed in, assign the previous values,\n         * to the temporary variables\n         */\n        setRegNamesAndValues(newA, newB);\n\n        var cmpResult = service.cmpResult;\n        var aSign = getSign(service.a);\n        var bSign = getSign(service.b);\n        var cmpSign = null;\n\n        var operationMap = {\n            'mov': mov,\n            'add': add,\n\n            'sub': sub,\n            'cmp': sub,\n\n            'mul': mul,\n            'div': div,\n            'and': and,\n            'or': or,\n            'xor': xor,\n            'test': test,\n            'not': not,\n            'end': end\n        };\n\n        service.cmpResult = operationMap[operation]();\n        return service.cmpResult;\n\n        function mov() {\n            registerService.setValueOfReg(service.aRegName, service.b);\n            cmpResult = service.b;\n\n            return cmpResult;\n        }\n\n        function add() {\n            cmpResult = service.a + service.b;\n\n            setCF(false);\n            setOF(false);\n\n            if (Math.abs(cmpResult) > service.maxValue) {\n                setCF(true);\n                cmpResult = truncateResult(cmpResult);\n            }\n\n            cmpSign = getSign(cmpResult);\n            if (signChanged(aSign, bSign, cmpSign)) {\n                    setOF(true);\n                }\n                \n            registerService.setValueOfReg(service.aRegName, cmpResult);\n\n            return cmpResult;\n        }\n\n        function sub() {\n            setCF(false);\n            setOF(false);\n            setZF(false);\n            \n            cmpResult = truncateResult(service.a - service.b);\n                            \n            if (service.b > service.a) {\n                setCF(true);\n            }\n\n            if (service.b === service.a) {\n                setZF(true);\n            }\n\n            cmpSign = getSign(cmpResult);\n\n            if (signChanged(aSign, bSign, cmpSign)) {\n                setOF(true);\n            }\n            \n            registerService.setValueOfReg(service.aRegName, cmpResult);\n\n            return cmpResult;\n        }\n\n        function mul() {\n            setCF(false);\n            setOF(false);\n            setZF(false);\n\n            cmpResult = service.a * service.b;\n\n            if (cmpResult === 0) {\n                setZF(true);\n            }\n\n            if (Math.abs(cmpResult) > service.maxValue) {\n                setCF(true);\n                cmpResult = truncateResult(cmpResult);\n            }\n\n            cmpSign = getSign(cmpResult);\n            if (signChanged(aSign, bSign, cmpSign)) {\n                    setOF(true);\n                }\n\n            return cmpResult;\n        }\n\n        function div() {\n            setOF(false);\n            \n            cmpResult = service.a / service.b;\n\n            if (cmpSign === Infinity) {\n                    setOF(true);\n                }\n\n            return cmpResult;\n        }\n\n        function and() {\n            cmpResult = service.a & service.b;\n            setSF(!!getSign(cmpResult));\n            registerService.setValueOfReg(service.aRegName, cmpResult);\n\n            return cmpResult;\n        }\n\n        function or() {\n            cmpResult = service.a | service.b;\n            setSF(!!getSign(cmpResult));\n            registerService.setValueOfReg(service.aRegName, cmpResult);\n\n            return cmpResult;\n        }\n\n        function xor() {\n            cmpResult = service.a ^ service.b;\n            setSF(!!getSign(cmpResult));\n            registerService.setValueOfReg(service.aRegName, cmpResult);\n\n            return cmpResult;\n\n        }\n\n        function test() {\n            setZF(false);\n            setSF(false);\n            \n            cmpResult = service.a & service.b;\n            \n            if (cmpResult === 0) {\n                setZF(true);\n            }\n            \n            setSF(!!getSign(cmpResult));\n\n            return cmpResult;\n        }\n\n        function not() {\n            cmpResult = ~service.a;\n            registerService.setValueOfReg(service.aRegName, cmpResult);\n\n            return cmpResult;\n        }\n\n        function end() {\n            console.log('end reached!');\n        }\n    }\n    \n    /**\n     * A helper funtion for checking if the sign has changed.\n     * Useful if called after the operation was executed.\n     * It needs both operator signs, and the result sign.\n     */\n    function signChanged(aSign, bSign, cmpSign) {\n        return ((aSign === bSign) &&\n                (cmpSign !== aSign));\n    }\n\n    /**\n     * A helper function for fetching the sign of a passed in number.\n     * The number is truncated (just in case),\n     * converted to it's binary form,\n     * split, so that each number is an element in an array,\n     * reversed (because fetching the [0] element of the array doesn't always represent it's sign),\n     * and it's last bit is fetched (which, when it's reversed, represents the number)\n     * \n     * The value will be 0 if the number is > 0, or 1 if the number is < 0.\n     */\n    function getSign(number) {\n        var bitSize = service.bitSize;\n        var truncatedValue = truncateResult(number);\n        var bitValue = truncatedValue.toString(2);\n        var sign = Number(bitValue.split('').reverse()[bitSize]);\n\n        return sign ? sign : 0;\n    }\n    \n    /**\n     * A function that returns truncated value of the number passed in.\n     */\n    function truncateResult(result) {\n        return Number(result) & service.maxValue;\n    }\n\n    // Function for setting the zero flag\n    function setZF(newZFValue) {\n        service.flags.ZF = newZFValue === undefined ?\n                        (service.cmpResult === 0) :\n                        newZFValue;\n        return service.flags;\n    }\n\n    // Function for setting the carry flag\n    function setCF(newCFValue) {\n        service.flags.CF = newCFValue === undefined ?\n                        service.flags.CF :\n                        newCFValue;\n        return service.flags;\n    }\n\n    // Function for setting the overflow flag\n    function setOF(newOFValue) {\n        service.flags.OF = newOFValue;\n\n        if (newOFValue === undefined) {\n            service.flags.OF = newOFValue === undefined ? \n                                service.flags.OF :\n                                newOFValue;\n        }\n        return service.flags;\n    }\n\n    // Sign/Negative flag\n    function setSF(newSFValue) {\n        service.flags.SF = newSFValue ||\n                        (service.cmpResult < 0) ||\n                        (service.cmpResult > service.maxValue);\n        return service.flags;\n    }\n  }\n})();\n","(function () {\n  'use strict';\n\n  angular.module('app')\n    .controller('CodeInputController', CodeInputController);\n\n  // jshint maxparams:15\n\n  CodeInputController.$inject = ['IFService',\n    'IFModel',\n    'IDService',\n    'IDModel',\n    'EXService',\n    'EXModel',\n    'WBService',\n    'WBModel',\n    'labelService',\n    'pcService',\n    'common',\n    '$interval',\n    'speculativeService',\n    'speculativeModel',\n    'jmpInstructionService'];\n\n  function CodeInputController(IFService,\n    IFModel,\n    IDService,\n    IDModel,\n    EXService,\n    EXModel,\n    WBService,\n    WBModel,\n    labelService,\n    pcService,\n    common,\n    $interval,\n    speculativeService,\n    speculativeModel,\n    jmpInstructionService) {\n    var vm = this;\n\n    vm.codeInput = 'mov ax, 0\\nmov bx, 2\\nl1:\\nadd ax, 1\\ncmp ax, bx\\njl l1\\nend';\n    vm.stepByStep = false;\n    vm.codeArray = [];\n    vm.pipelineStarted = false;\n    vm.endReached = false;\n    vm.trapFlag = false;\n\n    vm.IFModel = IFModel;\n    vm.IDModel = IDModel;\n    vm.EXModel = EXModel;\n    vm.WBModel = WBModel;\n    vm.common = common;\n\n    vm.doPrediction = doPrediction;\n    vm.goToNextBranchInstruction = goToNextBranchInstruction;\n\n    function doPrediction(codeInput) {\n      var codeSplitByLine = codeInput.split('\\n'),\n        codeArray = removeJustNewlines(codeSplitByLine);\n\n      speculativeModel.buffer = [];\n      vm.codeArray = labelService.setAndRemoveLabelsFromCodeArray(codeArray);\n\n      common.pipelineStarted = true;\n\n      // Initial PC value (not yet started)\n      pcService.pc = -1;\n\n      if (vm.stepByStep) {\n        pcService.setNewPc();\n        parseAll(pcService.pc, vm.codeArray);\n      } else {\n        setIterationInterval(vm.codeArray);\n      }\n    }\n\n    function goToNextBranchInstruction(codeArray) {\n      common.pipelineInterval = $interval(function () {\n      // common.pipelineActive = true;\n\n      // while (common.pipelineActive && !shouldStopExecution(codeArray)) {\n      // common.pipelineActive = false;\n      // if (common.pipelineActive) {\n\n        if (jmpOrGenFlagInstructionInEx() &&\n          vm.trapFlag) {\n          $interval.cancel(common.pipelineInterval);\n\n          vm.trapFlag = false;\n        } else {\n          vm.trapFlag = true;\n\n          iterateThePipeline(pcService.pc, codeArray)\n            .then(function () {\n\n              if (shouldStopExecution(codeArray)) {\n                $interval.cancel(common.pipelineInterval);\n                common.flushPipeline();\n                speculativeService.clear();\n                common.flushPipeline(false, false, false, true);\n                common.pipelineStarted = false;\n                common.pipelineActive = false;\n              }\n            });\n        }\n      }, 10);\n    }\n\n    function jmpOrGenFlagInstructionInEx() {\n      return EXModel.instructionsInEX.some(function (instruction) {\n        return jmpInstructionService.isJmpInstruction(instruction.operation) ||\n          jmpInstructionService.isFlagGenInstruction(instruction.operation);\n      });\n    }\n\n    function setIterationInterval(codeArray) {\n      common.pipelineInterval = $interval(function () {\n      // if (common.pipelineActive) {\n\n      iterateThePipeline(pcService.pc, codeArray)\n        .then(function () {\n\n          if (shouldStopExecution(codeArray)) {\n            $interval.cancel(common.pipelineInterval);\n            common.flushPipeline();\n            speculativeService.clear();\n            common.flushPipeline(false, false, false, true);\n            common.pipelineStarted = false;\n            common.pipelineActive = false;\n          } \n          // else {\n          //   setIterationInterval(codeArray);\n          // }\n          }, 10);\n        });\n      // }\n    }\n\n    function shouldStopExecution(codeArray) {\n      var noMoreInPipeline = common.isPipelineEmpty(),\n      noMoreInSpeculative = speculativeService.modelIsEmpty(),\n      endReached = WBService.endReached;\n\n      return (noMoreInPipeline && noMoreInSpeculative && endReached);\n    }\n\n    function removeJustNewlines(arrayWithNewlines) {\n      var arrayWithoutNewlines = arrayWithNewlines.filter(function (value) {\n        return value !== '';\n      });\n\n      return arrayWithoutNewlines;\n    }\n\n    function iterateThePipeline(pc, codeArray, howMany) {\n\n      return pipeThroughAll()\n        .then(function () {\n          pcService.setNewPc();\n          var parsePromise = parseAll(pcService.pc, codeArray, howMany);\n          return parsePromise;\n        });\n    }\n\n    function parseAll(pc, codeArray, howMany) {\n      return IFService.parse(pc, codeArray, 1)\n        .then(IDService.parse)\n        .then(EXService.parse)\n        .then(WBService.parse)\n        .then(function (response) {\n          console.log(response);\n        });\n    }\n\n    function pipeThroughAll() {\n      return WBService.pipeThrough()\n        .then(EXService.pipeThrough)\n        .then(IDService.pipeThrough)\n        .then(IFService.pipeThrough);\n    }\n\n  }\n})();\n\n// Following are the conditional jump instructions used on signed data used for arithmetic operations −\n//\n// Instruction\tDescription\tFlags tested\n// JE/JZ\tJump Equal or Jump Zero\tZF\n// JNE/JNZ\tJump not Equal or Jump Not Zero\tZF\n// JG/JNLE\tJump Greater or Jump Not Less/Equal\tOF, SF, ZF\n// JGE/JNL\tJump Greater/Equal or Jump Not Less\tOF, SF\n// JL/JNGE\tJump Less or Jump Not Greater/Equal\tOF, SF\n// JLE/JNG\tJump Less/Equal or Jump Not Greater\tOF, SF, ZF\n// Following are the conditional jump instructions used on unsigned data used for logical operations −\n//\n// Instruction\tDescription\tFlags tested\n// JE/JZ\tJump Equal or Jump Zero\tZF\n// JNE/JNZ\tJump not Equal or Jump Not Zero\tZF\n// JA/JNBE\tJump Above or Jump Not Below/Equal\tCF, ZF\n// JAE/JNB\tJump Above/Equal or Jump Not Below\tCF\n// JB/JNAE\tJump Below or Jump Not Above/Equal\tCF\n// JBE/JNA\tJump Below/Equal or Jump Not Above\tAF, CF\n// The following conditional jump instructions have special uses and check the value of flags −\n//\n// Instruction\tDescription\tFlags tested\n// JXCZ\tJump if CX is Zero\tnone\n// JC\tJump If Carry\tCF\n// JNC\tJump If No Carry\tCF\n// JO\tJump If Overflow\tOF\n// JNO\tJump If No Overflow\tOF\n// JP/JPE\tJump Parity or Jump Parity Even\tPF\n// JNP/JPO\tJump No Parity or Jump Parity Odd\tPF\n// JS\tJump Sign (negative value)\tSF\n// JNS\tJump No Sign (positive value)\tSF\n// The syntax for the J<condition> set of instructions −\n//\n// Example,\n//\n// CMP\tAL, BL\n// JE\tEQUAL\n// CMP\tAL, BH\n// JE\tEQUAL\n// CMP\tAL, CL\n// JE\tEQUAL\n// NON_EQUAL: ...\n// EQUAL: ...\n","(function() {\n  'use strict';\n\n  angular.module('app')\n    .directive('codeInput', codeInput);\n\n  codeInput.$inject = [];\n  function codeInput() {\n    var directive = {\n      restrict: 'E',\n      controller: 'CodeInputController',\n      controllerAs: 'ci',\n      templateUrl: 'app/codeInput/code-input.html'\n    };\n\n    return directive;\n  }\n})();\n","(function() {\n    'use strict';\n\n    angular.module('core')\n        .factory('common', common);\n\n    common.$inject = ['IFModel', \n                      'IDModel',\n                      'EXModel',\n                      'WBModel'];\n                      \n    function common(IFModel, \n                       IDModel,\n                       EXModel,\n                       WBModel) {\n                           \n        var service = {\n            pipelineStarted: false,\n            pipelineActive: false,\n            \n            flushPipeline: flushPipeline,\n            isPipelineEmpty: isPipelineEmpty,\n            instructionToText: instructionToText\n        };\n\n        return service;\n        \n        function flushPipeline(flushIf, flushId, flushEx, flushWb) {\n      \n            if (flushIf === undefined) {\n                IFModel.flush();\n                IDModel.flush();\n                EXModel.flush();\n            } else {\n            \n                if (flushIf) {\n                    IFModel.flush();\n                }\n                \n                if (flushId) {\n                    IDModel.flush();\n                }\n                \n                if (flushEx) {\n                    EXModel.flush();\n                }\n                \n                if (flushWb) {\n                    WBModel.flush();\n                }\n            }\n        }\n\n        function isPipelineEmpty() {\n            return IFModel.instructionsInIF.length === 0 &&\n                    IDModel.instructionsInID.length === 0 &&\n                    EXModel.instructionsInEX.length === 0 &&\n                    WBModel.instructionsInWB.length === 0;\n        }\n\n        function instructionToText(instructionObject) {\n            var firstOperatorExists = instructionObject.firstOperator !== (undefined || null);\n            var secondOperatorExists = instructionObject.secondOperator !== (undefined || null); \n\n            return instructionObject.operation + ' ' +\n            (firstOperatorExists ?\n             instructionObject.firstOperator :\n             '') +\n             (secondOperatorExists ? \n             (', ' + instructionObject.secondOperator) :\n             (''));\n        }\n    }\n})();","(function() {\n    'use strict';\n    \n  /*jshint maxcomplexity: false*/\n    angular.module('core')\n        .factory('jmpInstructionService', jmpInstructionService);\n\n    jmpInstructionService.$inject = ['aluService'];\n    function jmpInstructionService (aluService) {\n        var service = {\n            jmpInstructions: [],\n            isJmpInstruction: isJmpInstruction,\n            isFlagGenInstruction: isFlagGenInstruction,\n            checkBranchCondition: checkBranchCondition\n        };\n        \n        activate();\n\n        return service;\n        \n        function activate() {\n            service.jmpInstructions = ['jmp', 'je', 'jz', 'jne',\n                                        'jnz', 'jg', 'jnle', 'jge',\n                                        'jnl', 'jl', 'jnge', 'jle',\n                                        'jng'];\n            service.flagGenInstructions = ['test', 'cmp'];\n        }\n        \n        function isJmpInstruction(operation) {\n            return service.jmpInstructions.indexOf(operation) !== -1;\n        }\n\n        function isFlagGenInstruction(operation) {\n            return service.flagGenInstructions.indexOf(operation) !== -1;            \n        }\n        \n        function checkBranchCondition(operation) {\n            var aluFlags = aluService.flags;\n            var aluFlagMap = {\n                'jmp': true,\n\n                'je': aluFlags.ZF,\n                'jz': aluFlags.ZF,\n\n                'jne': !aluFlags.ZF,\n                'jnz': !aluFlags.ZF,\n\n                'jg': (!aluFlags.ZF && (aluFlags.SF === aluFlags.OF)),\n                'jnle': (!aluFlags.ZF && (aluFlags.SF === aluFlags.OF)),\n\n                'jge': aluFlags.SF === aluFlags.OF,\n                'jnl': aluFlags.SF === aluFlags.OF,\n\n                'jl': (aluFlags.SF !== aluFlags.OF),\n                'jnge': (aluFlags.SF !== aluFlags.OF),\n\n                'jle': (aluFlags.ZF) || (aluFlags.SF !== aluFlags.OF),\n                'jng': (aluFlags.ZF) || (aluFlags.SF !== aluFlags.OF)\n            };\n\n            return aluFlagMap[operation];\n        }\n    }\n})();\n","(function() {\n    'use strict';\n\n    angular.module('core')\n        .factory('labelService', labelService);\n\n    labelService.$inject = [];\n    function labelService() {\n        var service = {\n            labelArray: [],\n            \n            getAddress: getAddress,\n            setLabelAddress: setLabelAddress,\n            setAndRemoveLabelsFromCodeArray: setAndRemoveLabelsFromCodeArray\n        };\n\n        return service;\n        \n        function setLabelAddress(label, address) {\n            var objectToPush = {};\n            objectToPush[label.toLowerCase()] = address;\n            service.labelArray.push(objectToPush);\n        }\n        \n        function getAddress(label) {\n            var labelObjectToReturn = null;\n                        \n            service.labelArray.some(function(labelObject) {\n                if (labelObject[label] !== undefined) {\n                    labelObjectToReturn = labelObject;\n                    return true;\n                }\n            });\n            \n            return labelObjectToReturn[label];\n        }\n        \n        function setAndRemoveLabelsFromCodeArray(codeArray) {\n            var codeArrayToReturn = codeArray;\n            var index = 0;\n            \n            while (index < codeArray.length){\n                var codeString = codeArray[index];\n                \n                if (codeString.indexOf(':') !== -1) {\n                    var label = codeString.slice(0, codeString.indexOf(':'));\n                    \n                    codeArrayToReturn.splice(index, 1);\n                    setLabelAddress(label, index);\n                }\n                else {\n                    index++;\n                }\n            }            \n            return codeArrayToReturn;\n        }\n    }\n})();","(function() {\n    'use strict';\n\n    angular.module('core')\n        .factory('pcService', pcService);\n\n    pcService.$inject = [];\n    function pcService() {\n        var service = {\n            pc: -1,\n            branchesPredictedTaken: [],\n            overridePc: null,\n\n            setNewPc: setNewPc,\n            getLastBitsOfPc: getLastBitsOfPc\n        };\n\n        return service;\n\n        function setNewPc() {\n\n            service.pc += 1;\n            if (service.overridePc !== null) {\n                service.pc = service.overridePc;\n                service.overridePc = null;\n            }\n        }\n\n        function getLastBitsOfPc(numOfBits, pcToUse) {\n            var pcInBits = pcToUse ? pcToUse.toString(2) : service.pc.toString(2),\n            lastBits = pcInBits.slice(-numOfBits);\n\n            return parseInt(lastBits, 2);\n        }\n    }\n})();\n","(function() {\n    'use strict';\n\n    angular.module('core')\n        .factory('EXModel', EXModel);\n\n    EXModel.$inject = [];\n    function EXModel() {\n        var service = {\n            currentPc: null,\n            returnPromise: null,\n            nextPredictionFalse: false,\n            instructionsInEX: [],\n            writeBackResults: [],\n\n            flush: flush\n        };\n\n        return service;\n  \n        function flush() {\n            service.currentPc = 0;\n            service.instructionsInEX = [];\n            service.writeBackResults = [];\n            var objectToResolve = {\n                currentPc: service.currentPc,\n                instructionSet: service.instructionsInEX,\n                writeBackResults: service.writeBackResults\n            };\n\n            // Resolving, so that the pipeline doesn't stall,\n            // even though we're flushing.\n            service.returnPromise.resolve(objectToResolve);\n        }\n    }\n})();\n","(function () {\n    'use strict';\n\n    angular.module('core')\n        .factory('EXService', EXService);\n    //jshint maxparams: 15\n    EXService.$inject = ['$q',\n        'aluService',\n        'jmpInstructionService',\n        'labelService',\n        'pcService',\n        'EXModel',\n        'WBService',\n        'common',\n        'speculativeModel',\n        'speculativeService',\n        'predictionMachinesService',\n        'corelationRegisterService',\n        'localHistoryTableService',\n        'Math'];\n    function EXService($q,\n        aluService,\n        jmpInstructionService,\n        labelService,\n        pcService,\n        EXModel,\n        WBService,\n        common,\n        speculativeModel,\n        speculativeService,\n        predictionMachinesService,\n        corelationRegisterService,\n        localHistoryTableService,\n        Math) {\n\n        // var flag = true;\n        var service = {\n            parse: parse,\n            pipeThrough: pipeThrough,\n            parseJumpInstruction: parseJumpInstruction\n        };\n\n        return service;\n\n        /**\n         * Set the current PC to the service, from the passed in object,\n         * set the array instructions to the service,\n         * and initiate the write back array to empty.\n         * \n         * Decodes the newley assigned instructions,\n         * and return a promise. \n         */\n        function parse(objectFromId) {\n\n            EXModel.currentPc = objectFromId.currentPc;\n            EXModel.instructionsInEX = objectFromId.instructionSet;\n            EXModel.writeBackResults = [];\n\n            decodeInstructions(EXModel.instructionsInEX);\n            decreaseDelay();\n            EXModel.returnPromise = $q.defer();\n\n            return EXModel.returnPromise.promise;\n        }\n\n        /**\n         * Parses the branch instruction,\n         * calculates the actual value(generates a flag),\n         * and then it compares it to the prediction.\n         * \n         * Depending on the prediction, we need to handle things differently.\n         */\n        function parseJumpInstruction(instruction, index) {\n            var branchTaken = jmpInstructionService.checkBranchCondition(instruction.operation),\n                labelAddress = labelService.getAddress(instruction.firstOperator),\n                currentOperationPc = EXModel.currentPc + index,\n                branchPredictedIndex = pcService.branchesPredictedTaken.indexOf(currentOperationPc),\n                delay = getRandomDelay(),\n                currentPrediction = predictionMachinesService.getCurrentPrediction(currentOperationPc);\n\n            /**\n             * Probably should remember the PC that generates the flag.\n             * TODO: Do that!\n             */\n            var branchInfo = {\n                pc: currentOperationPc,\n                jmpToPc: labelAddress,\n                delay: delay,\n                predictedValue: currentPrediction ? 1 : 0,\n                calculatedValue: branchTaken ? 1 : 0\n            },\n                corelationRegister = corelationRegisterService.getCopy(),\n                predictedArray = speculativeModel.formPredictedArray(speculativeModel.buffer),\n\n                localHistoryIndex = parseInt(corelationRegister.concat(predictedArray).join(''), 2),\n                useCor = corelationRegisterService.useCor,\n                useLht = localHistoryTableService.useLht;\n                \n                if(!useCor && useLht) {\n                    localHistoryIndex = \n                        pcService.getLastBitsOfPc(localHistoryTableService.numOfPcBits, currentOperationPc);\n                }\n                var localHistoryArray = localHistoryTableService.getCopyOfLocalHistoryArrayFor(localHistoryIndex),\n                predictionMachineIndex = localHistoryTableService.getLocalHistoryValue(localHistoryIndex),\n                predictionMachineValue = predictionMachinesService.getCopyOfMachine(predictionMachineIndex),\n\n                predictionOverrides = {\n                    localHistoryIndex: localHistoryIndex,\n                    localHistoryArray: localHistoryArray,\n                    predictionMachineIndex: predictionMachineIndex,\n                    predictionMachineValue: predictionMachineValue\n                };\n                \n            // Also, update all the predictions, except the ones at the corelation register.\n            predictionMachinesService.updatePredictionsExceptCorelation(branchInfo.predictedValue, branchInfo.pc);\n\n            speculativeService.createNewBranchBuffer(branchInfo, predictionOverrides);\n\n            speculativeModel.addingToSpeculative = true;\n        }\n\n        function calculateBranchInstruction(branchBufferObject) {\n            var predictedValue = branchBufferObject.branchInfo.predictedValue,\n                calculatedValue = branchBufferObject.branchInfo.calculatedValue,\n                branchPc = branchBufferObject.branchInfo.pc,\n                branchPredictedIndex = pcService.branchesPredictedTaken.indexOf(branchPc);\n\n            if (EXModel.nextPredictionFalse) {\n                calculatedValue = !calculatedValue;\n            }\n\n            // If branch should be taken, and it was predicted not taken \n            if (calculatedValue &&\n                !predictedValue) {\n                // Flush instructions\n                common.flushPipeline();\n\n                // Set the mispredicted flag to true\n                branchBufferObject.branchInfo.mispredicted = true;\n\n                // Set new PC\n                // pcService.pc = labelAddress;\n                branchBufferObject.branchInfo.mispredictionPc = branchBufferObject.branchInfo.jmpToPc;\n\n                branchBufferObject.branchInfo.predictedValue = branchBufferObject.branchInfo.calculatedValue;\n\n                // The execution loop needs to be broken \n                return true;\n            }\n\n            // If branch should be taken, and it was predicted taken \n            else if (calculatedValue &&\n                predictedValue) {\n\n                // Remove the prediction from the list of predicted taken\n                pcService.branchesPredictedTaken.splice(branchPredictedIndex, 1);\n\n                branchBufferObject.branchInfo.shouldCommit = true;\n            }\n\n            // If branch should not be taken, and it was predicted not taken \n            else if (!calculatedValue &&\n                !predictedValue) {\n\n                branchBufferObject.branchInfo.shouldCommit = true;\n            }\n\n            // If branch should not be taken, and it was predicted taken \n            else if (!calculatedValue &&\n                predictedValue) {\n\n                // Flush instructions in IF and ID\n                common.flushPipeline();\n\n                // Set the mispredicted flag to true\n                branchBufferObject.branchInfo.mispredicted = true;\n\n                branchBufferObject.branchInfo.mispredictionPc = branchPc + 1;\n\n                // Remove the prediction from the list of predicted taken\n                pcService.branchesPredictedTaken.splice(branchPredictedIndex, 1);\n\n                branchBufferObject.branchInfo.predictedValue = branchBufferObject.branchInfo.calculatedValue;\n\n\n                // The execution loop needs to be broken \n                return true;\n            }\n\n            // The execution loop should not be broken\n            return false;\n        }\n\n        function parseALUInstruction(instruction) {\n            EXModel.writeBackResults = executeInstructions(instruction);\n        }\n\n        /**\n         * Decrease the delay for calculation for all the stuff currently being calculated.\n         */\n        function decreaseDelay() {\n\n            speculativeModel.buffer.map(function (value, index) {\n                if (value.branchInfo.delay) {\n                    value.branchInfo.delay -= 1;\n                }\n\n                if (value.branchInfo.delay === 0) {\n                    value.branchInfo.calculated = true;\n                    calculateBranchInstruction(value);\n                    speculativeService.mergeAndCommitValues(value);\n                }\n                return value;\n            });\n\n            /**\n             * If no more values in speculative buffer, \n             * stop adding results to it.\n             */\n            if (speculativeModel.buffer.length === 0) {\n                speculativeModel.addingToSpeculative = false;\n            }\n        }\n\n        /**\n         * Helper function for getting the random delay.\n         * Between 4 and 40 cycles.\n         */\n        function getRandomDelay() {\n            return Math.floor((Math.random() * 40) + 4);\n        }\n\n        function decodeInstructions(instructionsToDecode) {\n\n            instructionsToDecode.some(function (operationObject, index) {\n                var operationFromId = operationObject.operation;\n                var isJmpInstruction = jmpInstructionService.isJmpInstruction(operationFromId);\n\n                if (isJmpInstruction) {\n                    var jmpTaken = parseJumpInstruction(operationObject, index);\n                    return jmpTaken;\n                } else {\n                    parseALUInstruction(operationObject);\n                }\n            });\n            return EXModel.instructionsInEX;\n        }\n\n        /**\n         * Create an object, which will be piped through to the next part in the pipeline.\n         * \n         * Passing the currentPc, \n         * the instruction array, \n         * the results to be written back,\n         * and resolve the returning promise with this object.\n         */\n        function pipeThrough() {\n\n            if (EXModel.returnPromise) {\n                var objectToPipe = {\n                    currentPc: EXModel.currentPc,\n                    instructionSet: EXModel.instructionsInEX,\n                    writeBackResults: EXModel.writeBackResults\n                };\n\n                EXModel.returnPromise.resolve(objectToPipe);\n                return EXModel.returnPromise.promise;\n            }\n\n            return $q.resolve();\n        }\n\n        function executeInstructions(instruction) {\n            var firstOperator = instruction.firstOperator;\n            var secondOperator = instruction.secondOperator;\n            var operation = instruction.operation;\n\n            var result = aluService.compareAndSetFlags(firstOperator, secondOperator, operation);\n            var writeBackObject = {\n                currentPc: EXModel.currentPc,\n                register: instruction.firstOperator,\n                result: result,\n                operation: operation\n            };\n\n            /**\n             * If instruction should be written back,\n             * then commit it to the speculative buffer.\n             * Else, don't commit it, because messes will happen.\n             */\n            if (speculativeModel.addingToSpeculative) {\n                if (WBService.shouldWriteBack(operation)) {\n                    speculativeService.addTo(firstOperator, result);\n                }\n            } else {\n                EXModel.writeBackResults.push(writeBackObject);\n            }\n\n            return EXModel.writeBackResults;\n        }\n    }\n})();","(function() {\n    'use strict';\n\n    angular.module('core')\n        .factory('IDModel', IDModel);\n\n    IDModel.$inject = [];\n    function IDModel() {\n        var service = {\n            currentPc: null,\n            returnPromise: null,\n            instructionsInID: [],\n            flush: flush\n        };\n\n        return service;\n\n        function flush() {\n            service.currentPc = 0;\n            service.instructionsInID = [];\n            var objectToResolve = {\n                currentPc: service.currentPc,\n                instructionSet: service.instructionsInID\n            };\n\n            // Resolving, so that the pipeline doesn't stall,\n            // even though we're flushing.\n            service.returnPromise.resolve(objectToResolve);\n        }\n    }\n})();\n","(function() {\n    'use strict';\n\n    angular.module('core')\n        .factory('IDService', IDService);\n\n    IDService.$inject = ['$q', 'IDModel'];\n    function IDService($q, IDModel) {\n        var service = {\n            parse: parse,\n            pipeThrough: pipeThrough,\n            decodeSingleInstruction: decodeSingleInstruction\n        };\n\n        return service;\n        \n        function parse(objectFromIf) {\n            IDModel.currentPc = objectFromIf.currentPc;\n            IDModel.instructionsInID = decodeInstructions(objectFromIf.instructionSet);\n            IDModel.returnPromise = $q.defer();\n            \n            return IDModel.returnPromise.promise;\n        }\n        \n        function pipeThrough() {\n            if (IDModel.returnPromise) {\n            \n                var objectToPipe = {\n                    currentPc: IDModel.currentPc,\n                    instructionSet: IDModel.instructionsInID\n                };\n                \n                IDModel.returnPromise.resolve(objectToPipe);\n                return IDModel.returnPromise.promise;\n            }\n            \n            return $q.resolve();\n        }\n\n        function decodeSingleInstruction(line) {\n            var removedCommaFromline = line.replace(',', '');\n                var splitBySpace = removedCommaFromline.split(' ');\n                \n                var decodedInstruction = {\n                    operation: splitBySpace[0].toLowerCase(),\n                    firstOperator: splitBySpace[1] === undefined ? \n                                                        null : \n                                                        splitBySpace[1].toLowerCase(),\n                    secondOperator: splitBySpace[2] === undefined ? \n                                                        null : \n                                                        splitBySpace[2].toLowerCase() \n                };\n\n            return decodedInstruction;\n        }\n        \n        function decodeInstructions(instructionsToDecode) {\n            var decodedInstructions = [];\n            \n            instructionsToDecode.forEach(function(line) {                \n                var newInstruction = decodeSingleInstruction(line);\n                \n                decodedInstructions.push(newInstruction);\n            });\n            return decodedInstructions;\n        }\n    }\n})();\n","(function() {\n    'use strict';\n\n    angular.module('core')\n        .factory('IFModel', IFModel);\n\n    IFModel.$inject = [];\n    function IFModel() {\n        var service = {\n            currentPc: null,\n            returnPromise: null,\n            instructionsInIF: [],\n\n            flush: flush\n        };\n\n        return service;\n\n        function flush() {\n            service.currentPc = 0;\n            service.instructionsInIF = [];\n            var objectToResolve = {\n                currentPc: service.currentPc,\n                instructionSet: service.instructionsInIF  \n            };\n\n            // Resolving, so that the pipeline doesn't stall,\n            // even though we're flushing.\n            service.returnPromise.resolve(objectToResolve);\n        }\n    }\n})();\n","(function() {\n    'use strict';\n\n    angular.module('core')\n        .factory('IFService', IFService);\n\n    IFService.$inject = ['$q', \n                        'IFModel',\n                        'IDService',\n                        'jmpInstructionService',\n                        'labelService',\n                        'pcService',\n                        'predictionMachinesService'];\n    function IFService($q,\n                        IFModel,\n                        IDService,\n                        jmpInstructionService,\n                        labelService,\n                        pcService,\n                        predictionMachinesService) {\n        var service = {\n            currentPc: null,\n            returnPromise: null,\n            instructionsInIF: [],\n            codeArrayInput: [],\n\n            parse: parse,\n            pipeThrough: pipeThrough\n        };\n\n        return service;\n        \n        /**\n         * Parses the instruction array, gets the required number of instructions \n         * (if nothing is passed, then it is presumed that the number of instructions is 1)\n         * from the instruction array.\n         * \n         * Returns a promise, which will be resolved when 'pipeThrough' is called.\n         */\n        function parse(currentPc, instructionArray, howManyInstructionsToPipe) {\n            IFModel.currentPc = currentPc || 0;\n            howManyInstructionsToPipe = howManyInstructionsToPipe || 1;\n            IFModel.returnPromise = $q.defer();\n            var sliceFrom = IFModel.currentPc;\n            var sliceTo = IFModel.currentPc + howManyInstructionsToPipe;\n            service.codeArrayInput = angular.copy(instructionArray);\n\n            var slicedInstructions = instructionArray.slice(sliceFrom, sliceTo);\n\n            checkForBranchInstructions(slicedInstructions);\n            IFModel.instructionsInIF = slicedInstructions;\n            return IFModel.returnPromise.promise;\n        }\n\n        function checkForBranchInstructions(instructionArray) {\n            var i = 0;\n\n            while (i < instructionArray.length) {\n                var currentLine = instructionArray[i];\n                var decodedInstruction = IDService.decodeSingleInstruction(currentLine);\n                var instructionPc = i + IFModel.currentPc;\n\n                var isJmpInstruction = jmpInstructionService.isJmpInstruction(decodedInstruction.operation);\n                var currentPrediction = predictionMachinesService.getCurrentPrediction(instructionPc) ? 1 : 0;\n\n                if (isJmpInstruction && \n                    currentPrediction) {\n\n                    var numOfInstructions = instructionArray.length - i - 1;\n                    var predictedAddress = getPredictedAddress(decodedInstruction);\n                    if (numOfInstructions > 0) {\n                    \n                        // We need to replace the instructions that are after the jump instruction\n                        // with the instructions that are predicted.\n                        var predictedValues = getPredictedValues(predictedAddress, numOfInstructions);\n\n                        // Append new instructions, to the array of instructions,\n                        // that will be passed to IDService.\n                        instructionArray.splice(i, \n                        numOfInstructions);\n                        instructionArray.concat(predictedValues);\n                    }\n\n                    /** Adding the predicted instruction\n                     *  to the array of predicted instructions.\n                     *  It will be used later, when the instruction executes\n                     */\n                    pcService.branchesPredictedTaken.push(instructionPc);\n\n                    // Setting the next PC.\n                    pcService.overridePc = predictedAddress + numOfInstructions;\n\n                }\n                i++;\n            }\n\n            return instructionArray;\n        }\n\n        function getPredictedValues(labelAddress, num) {\n            var sliceToAddress = labelAddress + num;\n            \n            return service.codeArrayInput.slice(labelAddress, sliceToAddress);        \n        }\n\n        function getPredictedAddress(instructionObj) {\n            var label = instructionObj.firstOperator;\n            return labelService.getAddress(label);\n        }\n        \n        /**\n         * Resolves the promise with the required number of instructions\n         */        \n        function pipeThrough() {\n            if (IFModel.returnPromise) {\n                var objectToPipe = {\n                    currentPc: IFModel.currentPc,\n                    instructionSet: IFModel.instructionsInIF  \n                };\n                IFModel.returnPromise.resolve(objectToPipe);\n                return IFModel.returnPromise.promise;\n            }\n            return $q.resolve();\n        }\n    }\n})();\n","(function() {\n    'use strict';\n\n    angular.module('core')\n        .factory('WBModel', WBModel);\n\n    WBModel.$inject = [];\n    function WBModel() {\n        var service = {\n            currentPc: null,\n            returnPromise: null,\n            instructionsInWB: [],\n            writeBackResults: [],\n\n            flush: flush\n        };\n\n        return service;\n        \n        function flush() {\n            service.currentPc = 0;\n            service.instructionsInWB = [];\n            service.writeBackResults = [];\n            service.returnPromise.resolve();            \n        }\n    }\n})();\n","(function () {\n    'use strict';\n\n    angular.module('core')\n        .factory('WBService', WBService);\n\n    WBService.$inject = ['registerService',\n        '$q',\n        'WBModel'];\n    function WBService(registerService,\n        $q,\n        WBModel) {\n        var dontWriteBack = ['cmp', 'end'];\n\n        var service = {\n            endReached: false,\n\n            parse: parse,\n            pipeThrough: pipeThrough,\n            shouldWriteBack: shouldWriteBack\n        };\n\n        return service;\n\n        function parse(objectFromEx) {\n            WBModel.currentPc = objectFromEx.currentPc;\n            WBModel.instructionsInWB = objectFromEx.instructionSet;\n            WBModel.writeBackResults = objectFromEx.writeBackResults;\n            writeBack(objectFromEx.writeBackResults);\n            WBModel.returnPromise = $q.defer();\n\n            return WBModel.returnPromise.promise;\n        }\n\n        function writeBack(writeBackSet) {\n            writeBackSet.forEach(function (writeBackObject) {\n                var dst = writeBackObject.register;\n                var value = writeBackObject.result;\n                var op = writeBackObject.operation;\n\n                if (op === 'end') {\n                    service.endReached = true;\n                }\n\n                if (shouldWriteBack(op)) {\n                    registerService.setValueOfReg(dst, value);\n                }\n            });\n        }\n\n        function shouldWriteBack(operation) {\n\n            /** If the operation is not in the dontWriteBack array\n             *  we shouldn't preform a WB operation on the first operator.\n             */\n            return dontWriteBack.indexOf(operation) === -1;\n        }\n\n        function pipeThrough() {\n            if (WBModel.returnPromise) {\n                WBModel.returnPromise.resolve(WBModel.writeBackResults);\n                return WBModel.returnPromise.promise;\n            }\n\n            return $q.resolve();\n        }\n    }\n})();","(function() {\n    'use strict';\n\n    angular.module('core')\n            .constant('Math', window.Math);\n})();","(function () {\n    'use strict';\n\n    angular.module('core')\n        .factory('registerService', registerService);\n\n    registerService.$inject = ['speculativeModel'];\n    function registerService(speculativeModel) {\n        var service = {\n            coreRegisters: {\n                ax: 0,\n                bx: 0,\n                cx: 0,\n                dx: 0,\n                sp: 0,\n                bp: 0,\n                si: 0,\n                di: 0\n            },\n            otherRegisters: {},\n\n            getValueOfReg: getValueOfReg,\n            setValueOfReg: setValueOfReg\n        };\n\n        return service;\n\n        /**\n         * Get the value with the regName,\n         * from the registers or from the speculated buffer.\n         * \n         * If not in core registers, check the other registers.\n         * If not in the other registers, assume that the value will be 0,\n         * and update the other registers.\n         * \n         * Finally, if a value like this exists in the speculated buffer, use it.\n         * If it doesn't exist, use the previously fetched from register value.\n         */\n        function getValueOfReg(regName) {\n            var regValue = 0,\n                speculativeLength = speculativeModel.buffer.length,\n                latestSpecualtedValues = speculativeLength ? \n                                        speculativeModel.buffer[speculativeLength - 1].valuesToCommit : 0,\n                // speculatedValueToUse = latestSpecualtedValues[regName];\n                speculatedValueToUse = getValueFromSpeculated(regName);\n\n            if (service.coreRegisters[regName] !== undefined) {\n                regValue = service.coreRegisters[regName];\n\n            } else if (service.otherRegisters[regName] !== undefined) {\n                regValue = service.otherRegisters[regName];\n            } else {\n                service.otherRegisters[regName] = 0;\n            }\n            regValue = speculatedValueToUse || regValue;\n\n            return regValue;\n        }\n\n        /**\n         * Go from top to bottom, of the speculative buffer,\n         * and get the latest value (if it exists in the buffer).\n         */\n        function getValueFromSpeculated(regName) {\n            var valueToReturn = null;\n            var tempBuffer = speculativeModel.buffer;\n            tempBuffer.reverse();\n\n            tempBuffer.some(function(value) {\n                if (value.valuesToCommit[regName]) {\n                    valueToReturn = value.valuesToCommit[regName];\n                    return true;\n                }\n            });\n            \n            // Return the buffer to the original order.\n            tempBuffer.reverse();\n            return valueToReturn;\n        }\n\n        function setValueOfReg(regName, regValue) {\n\n            if (service.coreRegisters[regName] !== undefined) {\n                service.coreRegisters[regName] = regValue;\n            } else {\n                service.otherRegisters[regName] = regValue;\n            }\n\n            return regName;\n        }\n    }\n})();","(function () {\n    'use strict';\n\n    angular.module('core')\n        .factory('speculativeModel', speculativeModel);\n\n    /**\n     * The speculatively executed values are in the object\n     * Example buffer array object: {\n     *      pc: 1234,\n     *      valuesToCommit: {\n     *          ax: 5,\n     *          bx: 6,\n     *          cx: 7,\n     *          ...\n     *          calculated: false\n     *      },\n     *      delay: 38,\n     *      predictedValue: 0,\n     *      calculatedValue: 1\n     * }\n     * \n     * If our prediction is correct, these values will replace the values in the memory.\n     * Otherwise these values will get discarded.\n     */\n    speculativeModel.$inject = [];\n    function speculativeModel() {\n        var service = {\n            addingToSpeculative: false,\n            buffer: [],\n            size: 6,\n\n            initialize: initialize,\n            setMaxNumberOfBits: setMaxNumberOfBits,\n            shiftWithValue: shiftWithValue,\n            formPredictedArray: formPredictedArray\n        };\n        return service;\n\n        function initialize(newSize) {\n            var size = newSize || service.size;\n\n            setMaxNumberOfBits(size);\n        }\n\n        function setMaxNumberOfBits(numberOfBits) {\n            service.buffer = [];\n\n            for (var i = 0; i < numberOfBits; i++) {\n                service.buffer[i] = {\n                    branchInfo: {\n                        predictedValue: 0\n                        },\n                    valuesToCommit: {},\n                    predictionOverrides: {}\n                };\n            }\n        }\n\n        function shiftWithValue(newValue) {\n            service.buffer.shift();\n            service.buffer.push(newValue);\n        }\n\n        /**\n         * Helper function for forming an array which contains only predicted values,\n         * so we can concat it to the corelation register.\n         */\n        function formPredictedArray(bufferArray) {\n            var tempBuffer = [];\n\n            bufferArray.forEach(function (bufferItem) {\n                tempBuffer.push(bufferItem.branchInfo.predictedValue);\n            });\n\n            return tempBuffer;\n        }\n    }\n})();\n","(function () {\n    'use strict';\n\n    angular.module('core')\n        .factory('speculativeService', speculativeService);\n\n    /**\n     * The speculatively executed values are in the object\n     * Example buffer array object: {\n     *      pc: 1234,\n     *      valuesToCommit: {\n     *          ax: 5,\n     *          bx: 6,\n     *          cx: 7,\n     *          ...\n     *          calculated: true\n     *      },\n     *      predictedValue: 0\n     * }\n     * \n     * If our prediction is correct, these values will replace the values in the memory.\n     * Otherwise these values will get discarded.\n     */\n    speculativeService.$inject = ['$timeout',\n        'registerService',\n        'speculativeModel',\n        'corelationRegisterService',\n        'localHistoryTableService',\n        'predictionMachinesService',\n        'pcService',\n        'common',\n        '$interval'];\n    function speculativeService($timeout,\n        registerService,\n        speculativeModel,\n        corelationRegisterService,\n        localHistoryTableService,\n        predictionMachinesService,\n        pcService,\n        common,\n        $interval) {\n\n        var service = {\n            clear: clear,\n            modelIsEmpty: modelIsEmpty,\n            addTo: addTo,\n            comfitValues: commitValues,\n            createNewBranchBuffer: createNewBranchBuffer,\n            mergeAndCommitValues: mergeAndCommitValues,\n            setBufferToCalculated: setBufferToCalculated,\n            misprediction: misprediction,\n            getNextUncalculated: getNextUncalculated,\n            getLatestSpeculatedValues: getLatestSpeculatedValues\n        };\n        return service;\n\n        function modelIsEmpty() {\n            return speculativeModel.buffer.length === 0;\n        }\n\n        function clear() {\n            speculativeModel.buffer = [];\n        }\n\n        /**\n         * Create a new branch buffer, add it's pc, and an empty object,\n         * which will contain our may-be-commited set of values.\n         */\n        function createNewBranchBuffer(branchInfo, predictionOverrides) {\n            var newBranchBuffer = {\n                branchInfo: branchInfo,\n                valuesToCommit: {},\n                predictionOverrides: predictionOverrides\n            };\n\n            shiftWithValue(newBranchBuffer);\n            return speculativeModel.buffer[speculativeModel.buffer.length - 1];\n        }\n\n        /**\n         * Adds to the may-be-commited set of values,\n         * of the last branch buffer.\n         */\n        function addTo(dst, value) {\n            var lastBranchBuffer = speculativeModel.buffer.length - 1;\n\n            speculativeModel.buffer[lastBranchBuffer].valuesToCommit[dst] = value;\n        }\n\n        /**\n         * If the branch has been calculated, merge it forward.\n         */\n        function mergeAndCommitValues(valueBuffer) {\n            var newBuffer = speculativeModel.buffer,\n                lastCommitedIndex = getLastCommitedIndex(newBuffer);\n\n            /**\n            * Remove mispredictions from the buffer\n            */\n            newBuffer = removeMispredictions(newBuffer);\n\n            /**\n             * Commit all the correctly calculated values,\n             * to the memory.\n             * \n             * Only the values from the first (as in with index = 0) predicted branch, \n             * to the last calculated and correctly predicted branch,\n             * will be commited.\n             */\n            newBuffer.some(function (branchBuffer, branchIndex) {\n                if (branchBuffer.branchInfo.calculated) {\n                    var calculatedValue = branchBuffer.branchInfo.calculatedValue;\n                    lastCommitedIndex = branchIndex;\n\n                    if (corelationRegisterService.useCor) {\n                        corelationRegisterService.value.push(calculatedValue);\n                    }\n\n                    if (branchBuffer.branchInfo.shouldCommit) {\n                        commitValues(branchBuffer);\n                    }\n                }\n                return !branchBuffer.branchInfo.calculated;\n            });\n\n            /**\n             * Remove all the calculated values from the buffer,\n             * because they are not necessarry anymore.\n             */\n            var spliceTo = getNextUncalculated(newBuffer);\n            newBuffer.splice(0, spliceTo);\n        }\n\n        function shiftWithValue(newValue) {\n            var corelationSize = corelationRegisterService.value.length,\n                corelationMaxSize = corelationRegisterService.size,\n                speculativeSize = speculativeModel.buffer.length,\n                speculativeMaxSize = speculativeModel.size;\n\n            if (speculativeSize < speculativeMaxSize) {\n                speculativeModel.buffer.push(newValue);\n                if (corelationRegisterService.useCor) {\n                    corelationRegisterService.value.shift();\n                }\n            } else {\n                $interval.cancel(common.pipelineInterval);\n                window.alert('Too much! Stopping execution...');\n                $timeout(function () {\n                    common.flushPipeline();\n                    clear();\n                    corelationRegisterService.clear();\n                    localHistoryTableService.clear();\n                    predictionMachinesService.clear();\n                    common.pipelineActive = false;\n                    common.pipelineStarted = false;\n                    // console.log('That\\'s too much man!');\n                }, 10);\n            }\n        }\n\n        function getLastCommitedIndex(newBuffer) {\n            var lastCommitedIndex = -1;\n\n            newBuffer.some(function (branchBuffer, branchIndex) {\n\n                if (branchBuffer.branchInfo.calculated &&\n                    branchBuffer.branchInfo.shouldCommit) {\n\n                    lastCommitedIndex = branchIndex;\n                }\n                return !branchBuffer.branchInfo.shouldCommit;\n            });\n\n            return lastCommitedIndex;\n        }\n\n        /**\n         * Helper method for commiting the misprediction.\n         * \n         * Gets the first uncommited element in the buffer,\n         * (if it exists)\n         * and if it is mispredicted, commits it.\n         * \n         * We only do this for the first element, \n         * because all subsequent assumptions are false, and should not be commited.\n         */\n        function commitMisprediction(newBuffer, lastCommitedIndex) {\n            var firstUncommitedIndex = lastCommitedIndex + 1,\n                firstUncommited = newBuffer[lastCommitedIndex + 1];\n\n            /**\n             * Safeguard if the last commited one was at the end of the array\n             */\n            if (firstUncommited &&\n                firstUncommited.branchInfo.mispredicted) {\n\n                restorePredictions(firstUncommited, newBuffer);\n                var calculatedValue = firstUncommited.branchInfo.calculatedValue;\n\n                pcService.overridePc = firstUncommited.branchInfo.mispredictionPc;\n\n                // Update the predictions with the correct value.\n                predictionMachinesService.updatePredictions(calculatedValue);\n            }\n        }\n\n        /**\n         * Helper function for restoring the predictions, \n         * at which point the misprediction was made.\n         */\n        function restorePredictions(firstUncommited, newBuffer) {\n            newBuffer.reverse().some(function (mispredicted) {\n\n                if (mispredicted === firstUncommited) {\n                    return true;\n                }\n\n                /**\n                 * Restoring all the previous mispredictions.\n                 */\n                var localHistoryIndex = mispredicted.predictionOverrides.localHistoryIndex,\n                    localHistoryArray = mispredicted.predictionOverrides.localHistoryArray,\n                    predictionMachineIndex = mispredicted.predictionOverrides.predictionMachineIndex,\n                    predictionMachineValue = mispredicted.predictionOverrides.predictionMachineValue;\n\n                localHistoryTableService.setLocalHistoryArray(localHistoryIndex, localHistoryArray);\n                predictionMachinesService.setPrediction(predictionMachineIndex, predictionMachineValue);\n            });\n\n            // Restore the buffer to the original order\n            newBuffer.reverse();\n\n            // Finally, restore the last misprediction.\n            var localHistoryIndex = firstUncommited.predictionOverrides.localHistoryIndex,\n                localHistoryArray = firstUncommited.predictionOverrides.localHistoryArray,\n                predictionMachineIndex = firstUncommited.predictionOverrides.predictionMachineIndex,\n                predictionMachineValue = firstUncommited.predictionOverrides.predictionMachineValue;\n\n            localHistoryTableService.setLocalHistoryArray(localHistoryIndex, localHistoryArray);\n            predictionMachinesService.setPrediction(predictionMachineIndex, predictionMachineValue);\n\n        }\n\n        /**\n         * Helper function for removing all mispredictions.\n         * It removes the mispredicted element, \n         * and all the predictions that came after it.\n         * \n         * (All consequent predictions are mispredictions,\n         * because they are bassed on the assumption that all previous predictions,\n         * are coorect.)\n         */\n        function removeMispredictions(newBuffer) {\n            var mispredictedIndex = null,\n                updateWith = null,\n                restoreBranchBuffer = null,\n                pcToUse = 0;\n            newBuffer.some(function (branchBuffer, index, branchArray) {\n\n                if (branchBuffer.branchInfo.mispredicted) {\n\n                    // Set to null, so we don't trigget it again\n                    branchBuffer.branchInfo.mispredicted = null;\n                    updateWith = branchBuffer.branchInfo.calculatedValue;\n                    mispredictedIndex = index;\n                    pcToUse = branchBuffer.branchInfo.pc;\n                    pcService.overridePc = branchBuffer.branchInfo.mispredictionPc;\n\n                    restorePredictions(branchBuffer, newBuffer);\n                    return true;\n                }\n            });\n\n            if (mispredictedIndex !== null) {\n                var numberOfItemsToRemove = newBuffer.length - (mispredictedIndex + 1);\n\n                if (corelationRegisterService.useCor) {\n                    for (var i = 0; i < numberOfItemsToRemove; i++) {\n                        corelationRegisterService.value.splice(0, 0, 0);\n                    }\n                }\n                newBuffer.splice(mispredictedIndex + 1, numberOfItemsToRemove);\n\n                predictionMachinesService.updatePredictionsExceptCorelation(updateWith, pcToUse);\n            }\n\n            return newBuffer;\n        }\n\n        /**\n         * Helper function for setting the calculated flag.\n         */\n        function setBufferToCalculated(branchPc) {\n\n            speculativeModel.buffer.some(function (value, index, arr) {\n                if (value.pc === branchPc) {\n                    arr[index].calculated = true;\n                    return true;\n                }\n            });\n\n            return speculativeModel.buffer;\n        }\n\n        /**\n         * If we have a misprediction,\n         * everything predicted from this point onward should be flushed.\n         */\n        function misprediction(branchPc) {\n            var removeFromHere = null;\n\n            speculativeModel.buffer.some(function (value, index, arr) {\n\n                if (value.pc === branchPc) {\n                    var remaning = arr.length - index;\n                    arr.splice(index, remaning);\n                    return true;\n                }\n            });\n        }\n\n        /**\n         * Commit values of the first item in the array to the registers\n         * Be careful to only do it if the first value has been calculated.\n         */\n        function commitValues(branchBuffer) {\n            var valuesToCommit = branchBuffer.valuesToCommit;\n\n            angular.forEach(valuesToCommit, function (value, dst) {\n                registerService.setValueOfReg(dst, value);\n            });\n        }\n\n        /**\n         * Helper function for getting the next uncalculated.\n         */\n        function getNextUncalculated(buffer) {\n            var indexToReturn = buffer.length;\n\n            buffer.some(function (value, index) {\n                if (!value.branchInfo.calculated) {\n                    indexToReturn = index;\n                    return true;\n                }\n            });\n\n            return indexToReturn;\n        }\n\n        /**\n         * Helper function for getting the latest speculative buffer,\n         * and fetching the values to commit from it.\n         */\n        function getLatestSpeculatedValues() {\n            return speculativeModel.buffer[speculativeModel.buffer.length - 1].valuesToCommit;\n        }\n    }\n\n\n})();","(function () {\n\t'use strict';\n\n\tangular.module('app')\n\t\t.controller('CorelationRegisterController', CorelationRegisterController);\n\n\tCorelationRegisterController.$inject = ['corelationRegisterService',\n\t\t'localHistoryTableService',\n\t\t'predictionMachinesService',\n\t\t'speculativeModel'];\n\tfunction CorelationRegisterController(corelationRegisterService,\n\t\tlocalHistoryTableService,\n\t\tpredictionMachinesService,\n\t\tspeculativeModel) {\n\n\t\tvar vm = this;\n\n\t\tvm.corelationRegister = corelationRegisterService;\n\t\tvm.locationHistoryTable = localHistoryTableService;\n\t\tvm.predictionMachines = predictionMachinesService;\n\t\tvm.speculativeModel = speculativeModel;\n\n\t\tvm.updateValues = updateValues;\n\t\tvm.getStyleForPrediction = getStyleForPrediction;\n\n\t\tactivate();\n\n\t\tfunction activate() {\n\t\t\t// vm.corelationRegister.setMaxNumberOfBits(service.size);\n\t\t\tvm.corelationRegister.initializeCR();\n\t\t\t// speculativeModel.initialize();\n\t\t}\n\n\t\tfunction updateValues() {\n\t\t\tvar corelationTotalSize = corelationRegisterService.size,\n\t\t\t\tlhtSize = localHistoryTableService.size;\n\n\t\t\tvm.corelationRegister.setMaxNumberOfBits(vm.corelationRegister.size);\n\t\t\tvm.locationHistoryTable.initializeLHT();\n\t\t\tvm.predictionMachines.setMachineSize(corelationTotalSize, lhtSize);\n\t\t}\n\n\t\tfunction getStyleForPrediction(predictionInfo) {\n\t\t\tvar styleMap = {\n\t\t\t\t'true': { color: 'green' },\n\t\t\t\t'undefined': { color: 'red' }\n\t\t\t};\n\n\t\t\treturn styleMap[predictionInfo.calculated];\n\t\t}\n\t}\n})();\n","(function() {\n\t'use strict';\n\n\tangular.module('app')\n\t\t\t.directive('corelationRegister', corelationRegister);\n\n\tcorelationRegister.$inject = [];\n\tfunction corelationRegister() {\n\t\tvar directive = {\n\t\t\trestrict: 'E',\n\t\t\tcontroller: 'CorelationRegisterController',\n\t\t\tcontrollerAs: 'corReg',\n\t\t\ttemplateUrl: 'app/corelationRegister/corelation-register.html'\n\t\t};\n\n\t\treturn directive;\n\t}\n})();\n","\n(function() {\n\t'use strict';\n\n\tangular.module('app')\n\t\t.factory('corelationRegisterService', corelationRegisterService);\n\n  \tcorelationRegisterService.$inject = [];\n  \tfunction corelationRegisterService() {\n    \tvar service = {\n    \t\tvalue: [],\n\t\t\tsize: 12,\n\t\t\tuseCor: true,\n\n    \t\tsetMaxNumberOfBits: setMaxNumberOfBits,\n    \t\tshiftWithValue: shiftWithValue,\n\t\t\tgetRegisterValue: getRegisterValue,\n\t\t\tinitializeCR: initializeCR,\n\t\t\tgetCopy: getCopy,\n\t\t\tclear: clear\n    \t};\n\n    \treturn service;\n\n\t\tfunction initializeCR(newCRSize) {\n\t\t\tvar sizeOfCR = newCRSize || service.size;\n\n\t\t\tsetMaxNumberOfBits(sizeOfCR);\n\t\t}\n\n    \tfunction setMaxNumberOfBits(numberOfBits) {\n\t\t\tservice.value = [];\n\n            for (var i = 0; i < numberOfBits; i++) {\n                service.value[i] = 0;\n            }\n    \t}\n\n        function shiftWithValue(newValue) {\n            service.value.shift();\n            service.value.push(newValue);\n        }\n\n\t\tfunction getRegisterValue() {\n\t\t\tvar stringBinaryNumber = service.value.join('');\n\t\t\treturn parseInt(stringBinaryNumber, 2);\n\t\t}\n\n\t\tfunction getCopy() {\n\t\t\treturn angular.copy(service.value);\n\t\t}\n\n\t\tfunction clear() {\n\t\t\tservice.value = [];\n\t\t\tinitializeCR();\n\t\t}\n  \t}\n})();\n","(function () {\n  angular.module('app')\n    .controller('localHistoryTableController', localHistoryTableController);\n\n  localHistoryTableController.$inject = ['localHistoryTableService',\n    'pcService',\n    'corelationRegisterService',\n    'speculativeModel',\n    'predictionMachinesService'];\n  function localHistoryTableController(localHistoryTableService,\n    pcService,\n    corelationRegisterService,\n    speculativeModel,\n    predictionMachinesService) {\n    var vm = this;\n\n    vm.localHistoryTable = localHistoryTableService;\n    vm.predictionMachines = predictionMachinesService;\n    vm.updateValues = updateValues;\n    vm.checkIfChanged = checkIfChanged;\n    vm.corelationRegister = corelationRegisterService;\n\n    activate();\n\n    function activate() {\n      vm.localHistoryTable.initializeLHT();\n    }\n\n    function checkIfChanged(index) {\n      return localHistoryTableService.changed.indexOf(index) !== -1;\n    }\n\n    function updateValues(newLhtSize) {\n      var corelationTotalSize = corelationRegisterService.size,\n        lhtSize = localHistoryTableService.size;\n\n      localHistoryTableService.setSizeOfRegisters();\n      vm.predictionMachines.setMachineSize(corelationTotalSize, lhtSize);\n    }\n  }\n})();\n","(function() {\n\t'use strict';\n\n\tangular.module('app')\n\t\t\t.directive('localHistoryTable', localHistoryTable);\n\n\tlocalHistoryTable.$inject = [];\n\tfunction localHistoryTable() {\n\t\tvar directive = {\n\t\t\trestrict: 'E',\n\t\t\tcontroller: 'localHistoryTableController',\n\t\t\tcontrollerAs: 'lht',\n\t\t\ttemplateUrl: 'app/localHistoryTable/local-history-table.html'\n\t\t};\n\n\t\treturn directive;\n\t}\n})();\n","(function () {\n\t'use strict';\n\n\tangular.module('app')\n\t\t.factory('localHistoryTableService', localHistoryTableService);\n\n\tlocalHistoryTableService.$inject = ['corelationRegisterService',\n\t\t'speculativeModel',\n\t\t'Math'];\n\tfunction localHistoryTableService(corelationRegisterService,\n\t\tspeculativeModel,\n\t\tMath) {\n\t\tvar service = {\n\t\t\tvalue: [],\n\t\t\tsize: 3,\n\t\t\tchanged: [],\n\t\t\tnumOfPcBits: 3,\n\t\t\tuseLht: true,\n\n\t\t\tsetMaxNumberOfBits: setMaxNumberOfBits,\n\t\t\tsetSizeOfRegisters: setSizeOfRegisters,\n\t\t\tshiftWithValue: shiftWithValue,\n\t\t\tgetLocalHistoryValue: getLocalHistoryValue,\n\t\t\tinitializeLHT: initializeLHT,\n\t\t\tgetCopyOfLocalHistoryArrayFor: getCopyOfLocalHistoryArrayFor,\n\t\t\tsetLocalHistoryArray: setLocalHistoryArray,\n\t\t\tclear: clear\n\t\t};\n\n\t\tactivate();\n\n\t\treturn service;\n\n\t\tfunction activate() { }\n\n\t\tfunction initializeLHT(sizeOfRegister) {\n\t\t\tvar registerSize = sizeOfRegister || service.size,\n\t\t\t\tnumberOfRegisters = Math.pow(corelationRegisterService.size + speculativeModel.size, 2);\n\t\t\tservice.value = [];\n\n\t\t\tsetNumberOfRegisters(numberOfRegisters);\n\t\t\tsetSizeOfRegisters(registerSize);\n\t\t}\n\n\t\tfunction setNumberOfRegisters(numberOfLHTRegisters) {\n\t\t\tvar i = 0;\n\n\t\t\twhile (i < numberOfLHTRegisters) {\n\t\t\t\tservice.value[i++] = [];\n\t\t\t}\n\t\t}\n\n\t\tfunction setMaxNumberOfBits(numberOfBits) {\n\t\t\tvar numOfRegisters = Math.pow(2, numberOfBits);\n\n\t\t\tsetNumberOfRegisters(numOfRegisters);\n\n\t\t\tservice.value = service.value.map(function (value) {\n\t\t\t\tfor (var i = 0; i < numberOfBits; i++) {\n\t\t\t\t\tvalue[i] = 0;\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t});\n\t\t}\n\n\t\tfunction setSizeOfRegisters(newSize) {\n\n\t\t\tservice.value = service.value.map(function (value) {\n\t\t\t\tvalue = [];\n\n\t\t\t\tfor (var i = 0; i < newSize; i++) {\n\t\t\t\t\tvalue[i] = 0;\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t});\n\t\t}\n\n        function shiftWithValue(index, newValue) {\n\t\t\t\n\t\t\tif(service.changed.indexOf(index) === -1) {\n\t\t\t\tservice.changed.push(index);\n\t\t\t}\n\n            service.value[index].shift();\n            service.value[index].push(newValue);\n        }\n\n\t\tfunction getCopyOfLocalHistoryArrayFor(index) {\n\t\t\treturn angular.copy(service.value[index]);\n\t\t}\n\n\t\tfunction setLocalHistoryArray(index, arrayToSet) {\n\t\t\treturn angular.copy(arrayToSet, service.value[index]);\n\t\t}\n\n\t\tfunction getLocalHistoryValue(index) {\n\t\t\tvar lhStringValue = service.value[index].join('');\n\t\t\tvar lhValue = parseInt(lhStringValue, 2);\n\t\t\treturn lhValue;\n\t\t}\n\n\t\tfunction clear() {\n\t\t\tservice.value = [];\n\t\t\tservice.changed = [];\n\t\t\tinitializeLHT();\n\t\t}\n\t}\n})();\n","(function () {\n  'use strict';\n\n  angular.module('app')\n    .controller('PredictionMachinesController', PredictionMachinesController);\n\n  PredictionMachinesController.$inject = ['predictionMachinesService',\n    'corelationRegisterService',\n    'localHistoryTableService'];\n  function PredictionMachinesController(predictionMachinesService,\n    corelationRegisterService,\n    localHistoryTableService) {\n    var vm = this;\n\n    vm.numberOfMachines = predictionMachinesService.numOfMachines;\n    vm.predictionMachines = predictionMachinesService;\n    vm.checkIfChanged = checkIfChanged;\n\n    activate();\n\n    function activate() {\n      vm.predictionMachines.setMachineSize();\n    }\n\n    function checkIfChanged(index) {\n      return predictionMachinesService.changed.indexOf(index) !== -1;\n    }\n  }\n})();\n","(function() {\n  angular.module('app')\n    .directive('predictionMachines', predictionMachines);\n\n  predictionMachines.$inject = [];\n  function predictionMachines() {\n    var directive = {\n      restrict : 'E',\n      controller: 'PredictionMachinesController',\n      controllerAs: 'pm',\n      templateUrl: 'app/predictionMachines/prediction-machines.html'\n    };\n\n    return directive;\n  }\n})();\n","(function () {\n    'use strict';\n\n    angular.module('app')\n        .factory('predictionMachinesService', predictionMachinesService);\n\n    predictionMachinesService.$inject = ['corelationRegisterService',\n        'pcService',\n        'localHistoryTableService',\n        'speculativeModel'];\n    function predictionMachinesService(corelationRegisterService,\n        pcService,\n        localHistoryTableService,\n        speculativeModel) {\n        var service = {\n            numOfMachines: null,\n            sizeOfMachines: 2,\n            value: [],\n            changed: [],\n\n            setMachineSize: setMachineSize,\n            setPrediction: setPrediction,\n            getCurrentPrediction: getCurrentPrediction,\n            updatePredictions: updatePredictions,\n            updatePredictionsExceptCorelation: updatePredictionsExceptCorelation,\n            getCopyOfMachine: getCopyOfMachine,\n            getValueOfMachine: getValueOfMachine,\n            clear: clear\n        };\n\n        return service;\n\n        function setMachineSize(size1, size2) {\n            size1 = size1 || corelationRegisterService.size;\n            size2 = size2 || localHistoryTableService.size;\n\n            service.numOfMachines = Math.pow(2, size1 + size2);\n            service.value = [];\n\n            var i = 0;\n            while (i < service.numOfMachines) {\n                service.value[i++] = [1, 0];\n            }\n        }\n\n        function updateMachine(machineIndex, value) {\n            var machineValue = parseInt(service.value[machineIndex].join(''), 2),\n                maxValue = Math.pow(2, 2) - 1;\n\n            if (service.changed.indexOf(machineIndex) === -1) {\n                service.changed.push(machineIndex);\n            }\n\n            if (value === 0 &&\n                machineValue > 0) {\n                machineValue -= 1;\n            } else if (value === 1 &&\n                machineValue < maxValue) {\n                machineValue += 1;\n            }\n\n            var binaryValue = machineValue.toString(2);\n            service.value[machineIndex] = padWithZeroes(binaryValue, service.sizeOfMachines).split('');\n\n            return service.value;\n        }\n\n        function getCurrentPrediction(pcToUse) {\n            var useCor = corelationRegisterService.useCor,\n                useLht = localHistoryTableService.useLht,\n                corelationRegister,\n                predictedArray,\n\n                localHistoryIndex,\n                predictionMachineIndex,\n                predictionValString,\n                predictionValue;\n\n            if (useCor && !useLht) {\n                corelationRegister = corelationRegisterService.getCopy();\n                predictedArray = speculativeModel.formPredictedArray(speculativeModel.buffer);\n\n                predictionMachineIndex = parseInt(corelationRegister.concat(predictedArray).join(''), 2);\n                predictionValString = service.value[predictionMachineIndex].join('');\n                predictionValue = parseInt(predictionValString, 2);\n\n                return predictionValue >= 2 ? true : false;\n\n            } else if (!useCor && useLht) {\n                predictionMachineIndex = pcService.getLastBitsOfPc(localHistoryTableService.numOfPcBits, pcToUse);\n                predictionValString = service.value[predictionMachineIndex].join('');\n                predictionValue = parseInt(predictionValString, 2);\n\n                return predictionValue >= 2 ? true : false;\n            } else {\n                corelationRegister = corelationRegisterService.getCopy();\n                predictedArray = speculativeModel.formPredictedArray(speculativeModel.buffer);\n\n                localHistoryIndex = parseInt(corelationRegister.concat(predictedArray).join(''), 2);\n                predictionMachineIndex = localHistoryTableService.getLocalHistoryValue(localHistoryIndex);\n                predictionValString = service.value[predictionMachineIndex].join('');\n                predictionValue = parseInt(predictionValString, 2);\n            }\n\n            return predictionValue >= 2 ? true : false;\n\n        }\n\n        /**\n         * Helper function for forming an array which contains only predicted values,\n         * so we can concat it to the corelation register.\n         */\n        function formPredictedArray(bufferArray) {\n            var tempBuffer = [];\n\n            bufferArray.forEach(function (bufferItem) {\n                tempBuffer.push(bufferItem.branchInfo.predictedValue);\n            });\n\n            return tempBuffer;\n        }\n\n        function padWithZeroes(value, howMany) {\n            var zeroes = '';\n            for (var i = 0; i < howMany; i++) {\n                zeroes += '0';\n            }\n\n            return (zeroes + value).slice(-howMany);\n        }\n\n        function setPrediction(predictionIndex, predictionValueToSet) {\n            service.value[predictionIndex] = predictionValueToSet;\n        }\n\n        function updatePredictions(value) {\n            var useCor = corelationRegisterService.useCor,\n                useLht = localHistoryTableService.useLht,\n                corelationRegister = corelationRegisterService.getCopy(),\n                predictedArray = speculativeModel.formPredictedArray(speculativeModel.buffer),\n\n                // localHistoryIndex = corelationRegisterService.getRegisterValue(),\n                localHistoryIndex = parseInt(corelationRegister.concat(predictedArray).join(''), 2),\n                predictionMachineIndex = localHistoryTableService.getLocalHistoryValue(localHistoryIndex);\n\n            if (useCor && !useLht) {\n                predictionMachineIndex = localHistoryIndex;\n            } else if (!useCor && useLht) {\n                localHistoryIndex = pcService.getLastBitsOfPc(localHistoryTableService.numOfPcBits);\n                predictionMachineIndex = localHistoryTableService.getLocalHistoryValue(localHistoryIndex);\n            }\n            updateMachine(predictionMachineIndex, value);\n\n            if (useLht) {\n                localHistoryTableService.shiftWithValue(localHistoryIndex, value);\n            }\n\n            if (useCor) {\n                corelationRegisterService.shiftWithValue(value);\n            }\n        }\n\n        function updatePredictionsExceptCorelation(value, pcToUse) {\n            var useCor = corelationRegisterService.useCor,\n                useLht = localHistoryTableService.useLht,\n                corelationRegister = corelationRegisterService.getCopy(),\n                predictedArray = speculativeModel.formPredictedArray(speculativeModel.buffer),\n\n                localHistoryIndex = parseInt(corelationRegister.concat(predictedArray).join(''), 2),\n                predictionMachineIndex = localHistoryTableService.getLocalHistoryValue(localHistoryIndex);\n\n            if (useCor && !useLht) {\n                predictionMachineIndex = localHistoryIndex;\n            } else if (!useCor && useLht) {\n                localHistoryIndex = pcService.getLastBitsOfPc(localHistoryTableService.numOfPcBits, pcToUse);\n                predictionMachineIndex = localHistoryTableService.getLocalHistoryValue(localHistoryIndex);\n            }\n            updateMachine(predictionMachineIndex, value);\n\n            if (useLht) {\n                localHistoryTableService.shiftWithValue(localHistoryIndex, value);\n            }\n\n            updateMachine(predictionMachineIndex, value);\n            // localHistoryTableService.shiftWithValue(localHistoryIndex, value);\n        }\n\n        function getCopyOfMachine(machineIndex) {\n            return angular.copy(service.value[machineIndex]);\n        }\n\n        function getValueOfMachine(machineIndex) {\n            var stringBinaryNumber = service.value.join('');\n            return parseInt(stringBinaryNumber, 2);\n        }\n\n        function clear() {\n            service.value = [];\n            service.changed = [];\n            setMachineSize();\n        }\n    }\n})();\n","(function(/* BrowserSync-Brunch */) {\n  var url = \"//\" + location.hostname + \":3000/browser-sync/browser-sync-client.2.1.6.js\";\n  var bs = document.createElement(\"script\");\n  bs.type = \"text/javascript\"; bs.async = true; bs.src = url;\n  var s = document.getElementsByTagName(\"script\")[0];\n  s.parentNode.insertBefore(bs, s);\n})();"]}